[
{
	"uri": "/kr/lecture1/",
	"title": "Lecture 1",
	"tags": [],
	"description": "",
	"content": "Lecture 1 Course Introduction \u0026amp; Java Basics "
},
{
	"uri": "/kr/lecture2/",
	"title": "Lecture 2",
	"tags": [],
	"description": "",
	"content": "Lecture 2 Classes and Objects, Static, Types "
},
{
	"uri": "/kr/lecture3/",
	"title": "Lecture 3",
	"tags": [],
	"description": "",
	"content": "Lecture 3 Class Defining, Instantiating, Array of Objects, Static vs Non-static Managing Complexity(Helper Method) "
},
{
	"uri": "/kr/lecture4/",
	"title": "Lecture 4",
	"tags": [],
	"description": "",
	"content": "Lecture 4 Selection Sort, A Simple JUnit test, Testing Philosophy Selection Sort, Simpler JUnit Tests "
},
{
	"uri": "/kr/lecture5/",
	"title": "Lecture 5",
	"tags": [],
	"description": "",
	"content": "Lecture 5 PARAMETER PASSING, LISTS, ARRAYS PUBLIC VS PRIVATE, Nested Classes "
},
{
	"uri": "/kr/lecture6/",
	"title": "Lecture 6",
	"tags": [],
	"description": "",
	"content": "Lecture 6 SLList Upgrade, DLLs and Arrays Generic Lists, AList, 2D Arrays "
},
{
	"uri": "/kr/lecture7/",
	"title": "Lecture 7",
	"tags": [],
	"description": "",
	"content": "Lecture 7 Memory Efficiency, Obscurantism, Inheritance, Interface Overriding vs Overloading "
},
{
	"uri": "/kr/lecture8/",
	"title": "Lecture 8",
	"tags": [],
	"description": "",
	"content": "Lecture 8 java.util.List, Set in Java, Array Set 구현 Exception, Iteration, toString, StringBuilder, equals "
},
{
	"uri": "/kr/lecture9/",
	"title": "Lecture 9",
	"tags": [],
	"description": "",
	"content": "Lecture 9 DeepEquals, Vargs, Main Method "
},
{
	"uri": "/kr/lecture10/",
	"title": "Lecture 10",
	"tags": [],
	"description": "",
	"content": "Lecture 10 Map, Serializable and Storing Data Structures "
},
{
	"uri": "/kr/lecture11/",
	"title": "Lecture 11",
	"tags": [],
	"description": "",
	"content": "Lecture 11 More Inheritance, Constructor, Encapsulation and Module "
},
{
	"uri": "/kr/lecture11/content1/",
	"title": "More Inheritance, Constructor, Encapsulation and Module",
	"tags": [],
	"description": "",
	"content": "More Inheritance 클래스의 상속에 대해서 좀 더 자세하게 배워봅시다.\n그 전에 복습을 해보자면, 클래스의 상속은 extends를, interface의 상속에는 implements를 사용했습니다.\npublic class ExampleClass extends SthClass { ... public class ExampleClass implements SthInterface { ... 사진과 같이, 기반이 되는 Base Class와 Child Class가 나무처럼 얽히고 뻗어가면서 상속이 구성되었습니다.\nListOOP와 AList, SLList는 모두 지난 시간 구현하였던 클래스들입니다. 따라서, 이번에는 RotatingSLList라는 클래스를 상속에 기반해서 새로 설계해봅시다.\nRotatingSLList는 이름과 같이 모든 요소들이 한칸씩 뒤로 밀리고, 가장 뒤에 있던 요소는 맨 앞으로 돌아오는 List입니다.\n예를 들어, [1,2,3,4] 라는 배열이 있었을 때, rotation을 하면, [2,3,4,1] 이렇게 바뀌는 것이지요.\nbefore rotation [5, 9, 15, 22] after rotation [22, 5, 9, 15] rotation again [15, 22, 5, 9] 이를 구현하기 위해서, Base Class에서 이미 구현된 addFirst()와 removeLast() 메소드를 사용해야 할 것입니다. 현재 RotatingSLList 클래스는 SLList를 상속받고 있지요? 따라서 SLList에서 구현한 두 메소드를 자유롭게 사용할 수 있습니다.\npublic class RotatingSLList\u0026lt;Item\u0026gt; extends SLList\u0026lt;Item\u0026gt; { public void rotateRight() { Item x = removeLast(); addFirst(x); } ... 복습을 조금 더 해보자면, 클래스 상속, 즉 extends 받은 하위 클래스는 기본적으로 상위 클래스로부터 다음 3가지를 상속받습니다.\n모든 instance, static 변수들 - access specifier(public, private, protected)가 허락하는 한 모든 메소드들 모든 nested 클래스들 - 클래스 안에 구현한 클래스를 이야기합니다. (SLList내부의 Node 클래스가 해당합니다.) VengefulSLList VengefulSLList는 remove되는 모든 요소들을 담아 복수(vengeful)를 준비하는 SLList입니다.\n따라서, remove 된 요소들을 담는 별도의 List와, remove시 이를 갱신하는 구현이 필요합니다.\npublic class VengefulSLList\u0026lt;Item\u0026gt; extends SLList\u0026lt;Item\u0026gt; { SLList\u0026lt;Item\u0026gt; deletedItems; ... @Override public Item removeLast() { // sth } 이를 위해 removeLast를 Override하여 다시 구현하고자 합니다.\n하지만, 여기서 문제가 발생하는데요, removeLast 내부에서 사용되는 Node, sentinal과 같은 변수들이 상위 클래스인 SLList에서 private으로 선언되었기 때문에 접근이 불가합니다. 더불어, 코드가 반복되는 부분도 너무 많다는 문제가 있습니다.\n이를 해결하기 위해, 상위 클래스의 메소드를 호출하는, super 키워드를 사용하고자 합니다.\nsuper.removeLast()는 상위클래스인 SLList의 removeLast()를 호출하는 것과 동일한 효과를 갖습니다.\n이를 통해, removeLast를 아래와 같이 간단하게 구현 가능해집니다.\n@Override public Item removeLast() { Item x = super.removeLast(); deletedItems.addLast(x); return x; } 이제 구현한 VengefulList를 실행해봅시다.\npublic static void main(String[] args) { VengefulSLList\u0026lt;Integer\u0026gt; vs1 = new VengefulSLList\u0026lt;Integer\u0026gt;(0); vs1.addLast(1); vs1.addLast(5); vs1.addLast(10); vs1.addLast(13); // vs1 is now: [1, 5, 10, 13] vs1.removeLast(); vs1.removeLast(); // After deletion, vs1 is: [1, 5] // Should print out the numbers of the fallen, namely 10 and 13. System.out.print(\u0026#34;The fallen are: \u0026#34;); vs1.printLostItems(); } 실행 결과 1 5 10 13 1 5 The fallen are: 13 10 Constructor의 상속과 호출 아래와 같은 상황에서 Puddle 클래스 생성 시 Constructor는 어떤 순서로 호출 될까요?\nCode Result // Animal.java public class Animal { public Animal(){ System.out.println(\u0026#34;I am Animal\u0026#34;); } } // Dog.java public class Dog extends Animal { public Dog(){ System.out.println(\u0026#34;I am Dog\u0026#34;); } } // Puddle.java (with main method) public class Puddle extends Dog { public Puddle(){ System.out.println(\u0026#34;I am Puddle\u0026#34;); } public static void main(String[] args) { Puddle p = new Puddle(); } } I am Animal I am Dog I am Puddle Animal ← Dog ← Puddle의 상속 관계를 갖기 때문에, Puddle 생성 시 Animal, Dog 모두의 Constructor가 호출된 것입니다.\n이렇게 하위 클래스는 무조건 상위 클래스의 생성자를 모두 거쳐야 하며, 이는 피할 수 없습니다.\nVengefulSLList도 SLList의 상속을 받기 때문에, 생성 시 SLList의 생성자가 기본적으로 호출됩니다.\n상위 클래스의 생성자를 명시적으로 호출하고 싶다면, 메소드 super()를 사용하면 됩니다. 하지만, 이를 직접 호출하는 것은 비추천되고, Java에는 super() 메소드 앞에는 그 어떠한 코드도 존재하면 안된다든 법칙이 있어 이를 어길 시 컴파일 에러가 발생합니다.\n만약 Constructor에 매개변수가 있는 경우는 어떻게 호출할 수 있을까요?\n상위 클래스의, 매개변수가 있는 Constructor를 사용하고 싶다면, super(parameter) 의 형태로 사용 가능합니다.\n// SLList.java public class SLList\u0026lt;Blorp\u0026gt; implements List61B\u0026lt;Blorp\u0026gt; { public SLList(Blorp x) { size = 1; sentinel = new Node(null, null); sentinel.next = new Node(x, null); } ... } // VengefulSLList.java public class VengefulSLList\u0026lt;Item\u0026gt; extends SLList\u0026lt;Item\u0026gt; { public VengefulSLList(Item x) { super(x); deletedItems = new SLList\u0026lt;Item\u0026gt;(); } ... } 이런 일은 자주 없지만, 상위 클래스의 Constructor가 모두 매개변수를 필요로 한다면, 하위 클래스에서는 반드시 super(parameter)를 호출해야 할 것입니다.\nObject Class Object Class는 모든 클래스들의 최상위 레벨인 Super of Super Class입니다.\ncompareTo(), equals()와 같이 일부 메소드는 overriding 시 Object를 매개변수로 받는 것들이 있는데, 이들은 모두 Object Class에서 구현된 것이라 보면 됩니다.\n관심이 있다면 object의 원본 코드를 살펴보는 것도 좋은 공부가 될 것입니다. 👍\njdk7u-jdk/Object.java Encapsulation 프로그래머는 항상 코드의 복잡도를 줄이기 위해 고군분투해야합니다.\n우리가 핸드폰 내부 구성을 전혀 알지 못해도 잘만 핸드폰을 사용하는 것처럼, 작성된 코드 내부가 아무리 복잡해도 사용자에게는 이를 잘 포장해서 사용하기 편리하게 만드는 것이 중요합니다. 이를 Encapsulation이라 지칭하며, 규모있는 프로젝트에서는 반드시 고려해야 하는 요소가 됩니다.\n더불어 모듈은, 관련된 코드들이 모인 일종의 덩어리입니다. 우리가 컴퓨터 파일을 목적에 따라 폴더에 정리하는 것처럼 말이지요. 이렇게 묶인 모듈은 Encapsulation과 마찬가지로, 내부가 얼마나 복잡한지와 무관하게 외부와 소통하는 Method들만을 통해 손쉽게 사용이 가능해야합니다.\n모듈의 구현 시, 다른 클래스, 사용자와 상호작용하는 부분을 위해 public, private과 같은 access specifier 가 java에 구현되어 있는 것입니다.\nCase that Implementation Inheritance Breaks Encapsulation 상속 후 무분별한 Overriding 구현은 Encapsulation을 깨뜨리고 의도치 않은 동작을 유발할 수 있습니다.\nDog class의 bark와 barkMany를 구현하는 아래 예시들을 살펴봅시다. // Dog.java public class Dog { public void bark(){ barkMany(1); } public void barkMany(int N){ for(int i = 0; i \u0026lt; N; i++) System.out.println(\u0026#34;Bark!\u0026#34;); } } barkMany를 구현한 뒤, 이것의 특수 상황으로 bark를 구현한 모습입니다.\n지금은 전혀 문제되지 않는 코드이지만, 이를 상속받는 클래스에서 overriding 시 다음과 같은 문제가 발생할 수 있습니다.\npublic class VerboseDog extends Dog{ @Override public void barkMany(int N){ for(int i = 0; i \u0026lt; N; i++) bark(); } public static void main(String[] args) { VerboseDog vDog = new VerboseDog(); vDog.barkMany(2); } } 위 코드의 실행 결과는 어떻게 될까요?\nbarkMany()는 bark()를 호출합니다. 그런데, bark()는 또다시 barkMany()를 호출하지요. 이 순환이 계속되면서 무한 루프에 빠져버리게 됩니다. 클래스의 상속 시 이러한 점에 항상 조심해야 하며, 인터페이스 상속을 통해 방지할 수 있겠지만, 코드의 작성 시 프로그래머 자신의 룰을 만들어 일관되게 적용하는 것이 최선의 예방책일 것입니다.\n"
},
{
	"uri": "/kr/",
	"title": "한양대학교 융합전자공학부 OOP 정리노트",
	"tags": [],
	"description": "",
	"content": "한양대학교 융합전자공학부 OOP 정리노트 본 사이트는 2022년 \u0026ldquo;COM2018: Object-Oriented Programming\u0026rdquo; 강의 중 발생한 코드를 정리합니다.\n현재까지 정리된 강의는 다음과 같습니다.\nLecture 1. Course Introduction \u0026amp; Java Basics Lecture 2. Classes and Objects, Static, Types Lecture 3. Defining \u0026amp; Instantiating, Static vs Non-static, Managing - Complexity, Primitive Types Lecture 4. Unit Testing Lecture 5. Linked List (IntList \u0026amp; SLList), PUBLIC VS PRIVATE, Nested Classes, List \u0026amp; Array Lecture 6. Doubly Linked List, Generic Lists, AList Lecture 7. Inheritance and Interface, Overriding and Overloading Lecture 8. Java Built in Interfaces, Set, Exception, Iteration and Useful Class Methods Lecture 9. DeepEquals, Vargs, Main Method Lecture 10. Map, Serializable and Storing Data Structures Lecture 11. More Inheritance, Constructor, Encapsulation and Module "
},
{
	"uri": "/kr/lecture10/content1/",
	"title": "Map, Serializable and Storing Data Structures",
	"tags": [],
	"description": "",
	"content": "utils.Map 사용법 Map은 클래스가 아닌 interface이며, HashMap, TreeMap, LinkedHashMap등 다양한 자료구조들이 Map을 상속받고 있습니다.\nimport java.util.HashMap; import java.util.Map; public class MapExample { public static void main(String[] args) { Map\u0026lt;String, String\u0026gt; my_map = new HashMap\u0026lt;\u0026gt;(); my_map.put(\u0026#34;name\u0026#34;, \u0026#34;kim\u0026#34;); my_map.put(\u0026#34;nickname\u0026#34;, \u0026#34;Swimming Kim\u0026#34;); my_map.put(\u0026#34;address\u0026#34;, \u0026#34;Seoul, South Korea\u0026#34;); System.out.println(my_map); } } map 자료구조를 사용하다보면, key와 value에 별도로 접근하고 싶은 경우가 생깁니다.\nmap에 구현된 keySet(), values() 메소드와, enhanced-for-loop을 사용하면 손쉽게 map의 각 값들에 접근할 수 있습니다.\npublic static void main(String[] args) { Map\u0026lt;String, String\u0026gt; my_map = new HashMap\u0026lt;\u0026gt;(); my_map.put(\u0026#34;name\u0026#34;, \u0026#34;kim\u0026#34;); my_map.put(\u0026#34;nickname\u0026#34;, \u0026#34;Swimming Kim\u0026#34;); my_map.put(\u0026#34;address\u0026#34;, \u0026#34;Seoul, South Korea\u0026#34;); for(String key : my_map.keySet()){ System.out.printf(\u0026#34;current key is : %s\\n\u0026#34;, key); } System.out.println(my_map); } 실행 결과 current key is : address current key is : name current key is : nickname 출력 결과에서 알 수 있듯이, HashMap은 순서를 보장하지 않는 자료구조입니다.\n이후 프로젝트인 gitlet을 구현하기 위해, 각 Commit 마다 파일별 가리키는 버전을 담은 Map을 만들 수 있을 것이며, 버전의 갱신이 필요하다면, Map의 해당 value를 업데이트하면 되고, checkout 시에도 해당 버전의 map만을 찾아 파일 버전을 추적하면 손쉽게 구현할 수 있습니다.\nSerializable and Storing Data Structures 제가 만든 myDog이라는 Dog 타입의 Object가 있다고 해봅시다.\nDog myDog = new Dog(); myDog.feed(); myDog.care(); myDog.play(); 저는 myDog을 위해 밥도 많이 주고, 치료도 해주고 놀아도 주었습니다.\n그런데, 프로그램이 종료되는 순간, 저의 소중한 myDog은 사라져 버립니다.\nmyDog을 어떻게 저장할 수 있을까요? 텍스트로 myDog의 정보를 써두었다가 다시 불러올까요?\n# myDog.txt name = \u0026#34;Mr.Doge\u0026#34; age = 10 size = 12 care_count = 2 ... 하지만, 이렇게 사용하면 매번 코드를 작성할 때마다 텍스트의 라인을 한줄 한줄 읽어서 myDog에 대한 정보를 갱신해야 합니다.\nObject를 통째로 저장하고 불러올 수 있는 방법이 있다면 참 좋을 것 같다는 생각을 합니다.\n이러한 작업을 Serialize/Deserialize라고 하며, Java에서는 Serializable 이라는 인터페이스를 제공하고 있습니다. 사용 방법도 무척 간단하며, 단순히 Serializable을 상속받기만 하면 됩니다.\npublic class Something implements Serializable { ... } Serialize 작업을 위해 Stream이라는 것이 필요합니다. 하지만 본 강의에서는 이에 대해 직접적으로 다루지는 않겠으며, Serialize된 bytecode로의 변환 후 저장, 불러오기를 구현한 Utils라는 코드를 제공합니다. (\u0026gt; 를 눌러 전체 파일을 확인해보세요!)\nUtils.java import java.io.BufferedOutputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FilenameFilter; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.nio.file.Files; import java.nio.file.Paths; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.Formatter; import java.util.List; /** Assorted utilities. * @author P. N. Hilfinger */ class Utils { /* READING AND WRITING FILE CONTENTS */ /** Return the entire contents of FILE as a byte array. FILE must * be a normal file. Throws IllegalArgumentException * in case of problems. */ static byte[] readContents(File file) { if (!file.isFile()) { throw new IllegalArgumentException(\u0026#34;must be a normal file\u0026#34;); } try { return Files.readAllBytes(file.toPath()); } catch (IOException excp) { throw new IllegalArgumentException(excp.getMessage()); } } /** Return the entire contents of FILE as a String. FILE must * be a normal file. Throws IllegalArgumentException * in case of problems. */ static String readContentsAsString(File file) { return new String(readContents(file), StandardCharsets.UTF_8); } /** Write the result of concatenating the bytes in CONTENTS to FILE, * creating or overwriting it as needed. Each object in CONTENTS may be * either a String or a byte array. Throws IllegalArgumentException * in case of problems. */ static void writeContents(File file, Object... contents) { try { if (file.isDirectory()) { throw new IllegalArgumentException(\u0026#34;cannot overwrite directory\u0026#34;); } BufferedOutputStream str = new BufferedOutputStream(Files.newOutputStream(file.toPath())); for (Object obj : contents) { if (obj instanceof byte[]) { str.write((byte[]) obj); } else { str.write(((String) obj).getBytes(StandardCharsets.UTF_8)); } } str.close(); } catch (IOException | ClassCastException excp) { throw new IllegalArgumentException(excp.getMessage()); } } /** Return an object of type T read from FILE, casting it to EXPECTEDCLASS. * Throws IllegalArgumentException in case of problems. */ static \u0026lt;T extends Serializable\u0026gt; T readObject(File file, Class\u0026lt;T\u0026gt; expectedClass) { try { ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); T result = expectedClass.cast(in.readObject()); in.close(); return result; } catch (IOException | ClassCastException | ClassNotFoundException excp) { throw new IllegalArgumentException(excp.getMessage()); } } /** Write OBJ to FILE. */ static void writeObject(File file, Serializable obj) { writeContents(file, serialize(obj)); } /* OTHER FILE UTILITIES */ /** Return the concatentation of FIRST and OTHERS into a File designator, * analogous to the {@link java.nio.file.Paths.#get(String, String[])} * method. */ static File join(String first, String... others) { return Paths.get(first, others).toFile(); } /** Return the concatentation of FIRST and OTHERS into a File designator, * analogous to the {@link java.nio.file.Paths.#get(String, String[])} * method. */ static File join(File first, String... others) { return Paths.get(first.getPath(), others).toFile(); } /* SERIALIZATION UTILITIES */ /** Returns a byte array containing the serialized contents of OBJ. */ static byte[] serialize(Serializable obj) { try { ByteArrayOutputStream stream = new ByteArrayOutputStream(); ObjectOutputStream objectStream = new ObjectOutputStream(stream); objectStream.writeObject(obj); objectStream.close(); return stream.toByteArray(); } catch (IOException excp) { throw error(\u0026#34;Internal error serializing commit.\u0026#34;); } } /* MESSAGES AND ERROR REPORTING */ /** * Prints out MESSAGE and exits with error code -1. * Note: * The functionality for erroring/exit codes is different within Gitlet * so DO NOT use this as a reference. * Refer to the spec for more information. * @param message message to print */ public static void exitWithError(String message) { if (message != null \u0026amp;\u0026amp; !message.equals(\u0026#34;\u0026#34;)) { System.out.println(message); } System.exit(-1); } /** Return a RuntimeException whose message is composed from MSG and ARGS as * for the String.format method. */ static RuntimeException error(String msg, Object... args) { return new RuntimeException(String.format(msg, args)); } } 이를 사용하여 Object를 저장하고, 읽어들이는 예시를 살펴봅시다. public static void main(String[] args) { mkdirWithException(Student.FOLDER); Student stu1 = new Student(\u0026#34;Kim\u0026#34;, \u0026#34;Physics\u0026#34;, 26); stu1.saveObject(); Student stu2 = Student.fromFile(stu1.name); System.out.println(stu2); } 실행 결과 Name : Kim Subject : Physics Age : 26 저장된 파일을 열어보면 아래와 같이 알 수 없는 문자들이 가득합니다.\n본래 목적은 아니지만, 이를 통해 보안의 효과도 가질 수 있을 것입니다.\n��srcapers.Student˰�pv��IageLnametLjava/lang/String;Lsubjectq~xptKimtPhysics% "
},
{
	"uri": "/kr/lecture9/content1/",
	"title": "DeepEquals, Vargs, Main Method",
	"tags": [],
	"description": "",
	"content": "equals() \u0026amp; deepEquals() 지난 시간 배운 내용을 살짝 복습 해보겠습니다.\nReference Type의 비교 시 == 연산자는 단순히 메모리 박스의 주소만을 비교하는 것이기 때문에 의미가 없다는 것을 배웠습니다.\nSet\u0026lt;Integer\u0026gt; javaset = Set.of(5, 23, 42); Set\u0026lt;Integer\u0026gt; javaset2 = Set.of(5, 23, 42); System.out.println(javaset == javaset2); 실행 결과 : False 모든 클래스들의 Super Class인 Object 클래스에 구현된 equals() 메소드는 내부적으로 단순히 == 를 사용합니다. 그래서 equals() 메소드를 오버라이딩하여 사용했지요.\n출처 : Object.java 공식 github 2차원 배열, Object의 배열과 같은 다계층의 배열 비교 시, Array.equals()라는 메소드를 사용할 수 있습니다.\nint[] arr1 = new int [] {1, 2, 3, 4}; int[] arr2 = new int [] {1, 2, 3, 4}; int[] arr3 = new int [] {1, 2, 4, 3}; System.out.println(\u0026#34;is arr1 equals to arr2 : \u0026#34; + Arrays.equals(arr1, arr2)); System.out.println(\u0026#34;is arr1 equals to arr3 : \u0026#34; + Arrays.equals(arr1, arr3)); 실행 결과 true false --- String[] str1 = new String[3]; str1[0] = \u0026#34;a\u0026#34;; str1[1] = \u0026#34;b\u0026#34;; str1[2] = \u0026#34;c\u0026#34;; String[] str2 = new String[3]; str2[0] = \u0026#34;a\u0026#34;; str2[1] = \u0026#34;b\u0026#34;; str2[2] = \u0026#34;c\u0026#34;; System.out.println(Arrays.equals(str1, str2)); 실행 결과 true false 더불어, Java는 2차원 배열의 비교를 이를 위해 Arrays.deepEquals()라는 메소드도 제공합니다.\nint[][] arr2d_1 = {{0, 1}, {1, 0}}; int[][] arr2d_2 = {{0, 1}, {1, 0}}; System.out.println(\u0026#34;is arr1 equals to arr2 : \u0026#34; + Arrays.equals(arr2d_1, arr2d_2)); 실행 결과 false 참고로, deepEquals()는 3차원 이상의 배열도 비교할 수 있답니다.\nSystem.out.println(\u0026#34;is arr1 deepequals to arr2 : \u0026#34; + Arrays.deepEquals(arr2d_1, arr2d_2)); // true int[][][] arr3d_1 = {{ {0, 1}, {1, 0}}, { {0, 2}, {2, 0} }}; int[][][] arr3d_2 = {{ {0, 1}, {1, 0}}, { {0, 2}, {2, 0} }}; System.out.println(\u0026#34;is arr3d_1 deepequals to arr3d_2 : \u0026#34; + Arrays.deepEquals(arr3d_1, arr3d_2)); // true 지난 시간 구현하였던 ArraySet 클래스에도 equals() 메소드를 구현해보고자 합니다.\nequals()의 매개변수로 ArraySet을 넣고 싶지만, 이렇게 될 경우 overriding이 아닌 overloading이 되어 버립니다. (Object의 equals()함수 원형과 동일해야 하기 때문입니다.) 따라서 불가피하게 Type Casting이 필요합니다.\n@Override public boolean equals(Object other) { ArraySet\u0026lt;T\u0026gt; o = (ArraySet\u0026lt;T\u0026gt;) other; ... 불행하게도, 단순히 casting을 한다고 해서 문제가 해결되지는 않습니다.\nsize() 메소드가 없는 타입이 매개변수로 전달될 경우, o.size() 호출 시 ClassCastException 런타임 에러가 발생하기 때문입니다.\n@Override public boolean equals(Object other) { ArraySet\u0026lt;T\u0026gt; o = (ArraySet\u0026lt;T\u0026gt;) other; if (o.size() != this.size()) { return false; } } 따라서, Casting을 수행하기 전에, getClass() 메소드로 Object의 타입을 검사하여 럼타임 에러를 방지해야 합니다.\n@Override public boolean equals(Object other) { if (other.getClass() != this.getClass()) { return false; } ArraySet\u0026lt;T\u0026gt; o = (ArraySet\u0026lt;T\u0026gt;) other; if (o.size() != this.size()) { return false; } } 이제, 발생할 수 있는 예외처리와 최적화를 진행해봅시다.\n만약 사용자가 null, 혹은 의도치 않은 타입의 매개변수를 전달하게 되면, 오류가 발생할 것입니다. 이에 대한 예외처리도 추가해주었습니다.\n마지막으로, 자기 자신과 완정 동일한 Object가 비교 대상이 되는 경우, 굳이 item을 순회하면서 비교할 필요가 없기 때문에, 빠르게 결과를 return 해줍시다.\nif (other == null) { return false; } if (other.getClass() != this.getClass()) { return false; } ... 완성된 equals() 메소드는 아래와 같으며, 처음 구현할 시에는 고려해야 할 것도 많고 귀찮지만, 한번 구현해둔 이후에는 요긴하게 사용할 수 있을 것입니다.\n@Override public boolean equals(Object other) { if (this == other) { return true; } if (other == null) { return false; } if (other.getClass() != this.getClass()) { return false; } ArraySet\u0026lt;T\u0026gt; o = (ArraySet\u0026lt;T\u0026gt;) other; if (o.size() != this.size()) { return false; } for (T item : this) { if (!o.contains(item)) { return false; } } return true; } "
},
{
	"uri": "/kr/lecture8/content1/",
	"title": "java.util.List, Set in Java, Array Set 구현",
	"tags": [],
	"description": "",
	"content": "AList, Inheritance, Interface 일전, ListOOP라는 클래스로부터 상속받는 AList와 SLList 클래스를 구현하였습니다.\nAList는 Array기반의 List이며, SLList는 Linked List 기반의 List였지요.\nimport java.util.List; import java.util.ArrayList; public class Lecture8 { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; L = new ArrayList\u0026lt;\u0026gt;(); L.add(5); L.add(10); L.add(15); System.out.println(L); } } 그런데, Java에는 이미 ArrayList라는 내장 클래스가 존재하며, 파이썬의 list와 유사하게 편리하게 사용할 수 있습니다.\njava.util.List는 interface로, new List\u0026lt;\u0026gt;()와 같은 생성은 불가하지만 상속을 통해 ArrayList, Vector, LinkedList 등 java의 다양한 List 타입을 손쉽게 사용할 수 있습니다.\nimport java.util.List; import java.util.LinkedList; import java.util.ArrayList; import java.util.Vector; List\u0026lt;String\u0026gt; arr_list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; v_list = new Vector\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; linked_list = new LinkedList\u0026lt;\u0026gt;(); “Is-a” vs “Has-a” 다음과 같은 예시를 생각해 봅시다.\n사자는 동물이다 ⇒ O 사자는 표유류 동물이다. ⇒ O 사자는 고양이과 동물이다. ⇒ O https://namu.wiki/w/사자 위 그림에서 사자보다 높은 계층에 속하는 범주에 대해 사자 is-a Something의 관계가 성립하는 것을 확인할 수 있습니다.\n반면, 이번에는 다른 예시를 살펴보겠습니다.\n바퀴는 자동차다 ⇒ X 엔진은 자동차다 ⇒ X 시트는 자동차다 ⇒ X 바퀴는 자동차에 포함된다 라고는 말할 수 있지만 바퀴는 자동차다라고 말할 수는 없습니다.\n바퀴와 자동차 사이의 관계는 is-a가 아닌 has-a의 관계를 갖게 되며, 이런 경우 상속을 통해 구현하면 안될 것입니다. (객체지향에 대한 설계구조 없이 개발을 할 시 혼란스러움을 유발할 수 있는 요소가 됩니다.)\nhttp://me-resetsg.blogspot.com/ Set in Java set은 고등학교 시간에 배운 “집합”과 유사합니다. 집합의 주요한 특징으로, 집합 안에는 같은 값을 갖는 원소가 2개 이상 존재할 수 없습니다.\nhttps://en.wikipedia.org/wiki/Set_theory Java에서 Set은 다음과 같이 사용합니다. List와 마찬가지로 Set에는 HashSet, TreeSet, LinkedHashSet등 여러 종류가 있으며, 모두 interface인 Set을 상속받습니다.\nimport java.util.*; public class Lecture8 { public static void main(String[] args) { Set\u0026lt;String\u0026gt; S = new HashSet\u0026lt;\u0026gt;(); S.add(\u0026#34;Seoul\u0026#34;); S.add(\u0026#34;San Francisco\u0026#34;); S.add(\u0026#34;Los Angeles\u0026#34;); S.add(\u0026#34;Washington DC\u0026#34;); S.add(\u0026#34;Seoul\u0026#34;); System.out.println(S); } } // 결과 // [San Francisco, Washington DC, Seoul, Los Angeles] Seoul을 두 번 추가하였지만, Set의 특징으로 인해 배제되었습니다.\nArraySet 구현 이번 구현의 완성된 코드는 다음 링크에서 찾아볼 수 있습니다. CS61B - ArraySet.java\narray에 기반한 set 자료구조를 직접 구현해봅시다!\n생성자를 먼저 살펴보면, generic을 위해 Object 타입의 배열을 우선 생성한 뒤, 타입 T로 캐스팅하는 모습을 볼 수 있습니다.\npublic class ArraySet\u0026lt;T\u0026gt; { private T[] items; private int size; // the next item to be added will be at position size public ArraySet() { items = (T[]) new Object[100]; size = 0; } ... Set의 주요한 특징인, 중복을 허용하지 않는 부분은 contains라는 메소드로 구현하고자 합니다.\n모든 Array를 순회하면서, 이미 중복되는 값이 있다면 true를 반환합니다.\npublic boolean contains(T x) { for (int i = 0; i \u0026lt; size; i += 1) { if (items[i].equals(x)) { return true; } } return false; } contains를 구현하였다면, 이제 이는 add에 사용될 수 있습니다. Set에 add 시, 중복 검사를 먼저 거친 뒤, 통과된 요소만 새롭게 추가하는 것입니다. (size도 +1 해줘야 하겠지요)\npublic void add(T x) { if (contains(x)) { return; } items[size] = x; size += 1; } Java의 HashSet과 우리가 구현한 ArraySet을 비교해봅시다.\nArraySet 사용 시 public static void main(String[] args) { ArraySet\u0026lt;String\u0026gt; citySet = new ArraySet\u0026lt;\u0026gt;(); citySet.add(\u0026#34;Seoul\u0026#34;); citySet.add(\u0026#34;San Francisco\u0026#34;); citySet.add(\u0026#34;Los Angeles\u0026#34;); citySet.add(\u0026#34;Washington DC\u0026#34;); citySet.add(\u0026#34;Seoul\u0026#34;); System.out.println(citySet); } // 실행 결과 // {Seoul, San Francisco, Los Angeles, Washington DC} Set 사용 시 public static void main(String[] args) { Set\u0026lt;String\u0026gt; citySetJava = new HashSet\u0026lt;\u0026gt;(); citySetJava.add(\u0026#34;Seoul\u0026#34;); citySetJava.add(\u0026#34;San Francisco\u0026#34;); citySetJava.add(\u0026#34;Los Angeles\u0026#34;); citySetJava.add(\u0026#34;Washington DC\u0026#34;); citySetJava.add(\u0026#34;Seoul\u0026#34;); System.out.println(citySetJava); } // 실행 결과 // [San Francisco, Washington DC, Seoul, Los Angeles] 출력 순서가 약간 다르지만, Set에서 순서의 큰 의미는 없습니다.\n"
},
{
	"uri": "/kr/lecture8/content2/",
	"title": "Exception, Iteration, toString, StringBuilder, equals",
	"tags": [],
	"description": "",
	"content": "Exception 만약 Set에 null을 추가하게 되다면 어떻게 될까요?\nadd 자체는 되지 몰라도, contains 실행 시 null.equals()가 호출되면서 null point exception이 발생하게 됩니다.\nException in thread \u0026#34;main\u0026#34; java.lang.NullPointerException: - Cannot invoke \u0026#34;Object.equals(Object)\u0026#34; because \u0026#34;this.items[i]\u0026#34; is null at ArraySet.contains(ArraySet.java:18) at ArraySet.add(ArraySet.java:31) at ArraySet.main(ArraySet.java:127) 이러한 예외를 해결하기 위해 throw와 try/catch를 사용하는 예외처리 기법을 배워보도록 하겠습니다.\nJava에서 예외를 다루는 Exception은 Object의 상속을 받는 클래스입니다. 따라서, 예외 상황이 발생하는 경우, throw new를 통해 새로운 인스턴스를 생성하여 전달합니다.\n현재 런타임 에러를 다뤄야 하기 때문에 IllegalArgumentException를 사용하였습니다.\npublic void add(T x) { if (x == null) { throw new IllegalArgumentException(\u0026#34;can\u0026#39;t add null\u0026#34;); } if (contains(x)) { return; } items[size] = x; size += 1; } 예외가 발생하면, 프로그램은 기본적으로 종료됩니다. 프로그램이 종료되지 않게 하고 싶다면, catch문을 통해 이 상황을 다룰 수 있습니다.\npublic void add(T x) { if (x == null) { throw new IllegalArgumentException(\u0026#34;can\u0026#39;t add null\u0026#34;); } ... } ... public static void main(String[] args) { ... try{ citySet.add(null); } catch (IllegalArgumentException e) { System.out.println(e); } System.out.println(citySet); ... 현재는 IllegalArgumentException만을 catch 하였기 때문에, 그 이외의 예외들은 처리할 수 없습니다.\n하지만, 만약 Exception을 catch하도록 하면, 다형성을 사용하여 모든 예외 처리가 가능할 것입니다.\nIteration Java에 내장된 Set이나 List는 아래와 같은 Enhanced-For Loop을 사용할 수 있습니다.\n하지만, 이를 사용하기 위해서는 class내부에 Iterator를 구현해주어야 하며, 계속해서 구현중인 ArraySet을 통해 이에 대해서 알아봅시다.\npublic static void main(String[] args) { Set\u0026lt;Integer\u0026gt; javaset = new HashSet\u0026lt;\u0026gt;(); javaset.add(5); javaset.add(23); javaset.add(42); for (int i : javaset) { System.out.println(i); } } Iteration 구현 1 - Iterator타입을 반환하는 iterator() 메소드가 구현되어 있어야 합니다. public Iterator\u0026lt;T\u0026gt; iterator() { } Iteration 구현 2 - iterator() 메소드가 return 할 Iterator Class를 구현합니다. private class ArraySetIterator implements Iterator\u0026lt;T\u0026gt; { private int wizPos; public ArraySetIterator() { wizPos = 0; } @Override public boolean hasNext() { return wizPos \u0026lt; size; } @Override public T next() { return items[wizPos++]; } } 현 상황에서 Array에 담긴 item이 100개가 넘어가면 오류가 발생하지만 우선 무시하고 진행하겠습니다.\nIterator는 인터페이스이며, 상속을 받을 시, boolean hasNext()와 T next()를 반드시 구현해주어야 합니다. hasNext는 다음 요소가 있는지 확인을 위한 메소드이며, next는 다음 요소의 값을 반환합니다. 현재 자신이 바라보고 있는 지점이 어디인지 알아야 하기 때문에, ArraySetIterator는 wizPos라는 멤버 변수를 갖게 됩니다. Iteration 구현 3 - 이제, iterator() 메소드에서 방금 구현한 따끈따끈한 ArraySetIterator class를 return하도록 수정합니다. public Iterator\u0026lt;T\u0026gt; iterator() { return new ArraySetIterator(); } 이제 iterator를 사용해봅시다.\npublic static void main(String[] args) { ArraySet\u0026lt;String\u0026gt; citySet = new ArraySet\u0026lt;\u0026gt;(); citySet.add(\u0026#34;Seoul\u0026#34;); citySet.add(\u0026#34;San Francisco\u0026#34;); citySet.add(\u0026#34;Los Angeles\u0026#34;); citySet.add(\u0026#34;Washington DC\u0026#34;); citySet.add(\u0026#34;Seoul\u0026#34;); Iterator\u0026lt;String\u0026gt; itr = citySet.iterator(); while(itr.hasNext()){ System.out.println(itr.next()); } } Iteration 구현 4 - Iterable 상속 우리의 목표인 Enhanced For-Loop을 사용하기 위해서, Iterable 인터페이스를 상속받도록 하는 추가 작업이 필요합니다. 이 클래스가 반복자를 갖고 있다는 것을 명시적으로 알려주는 작업이지요. 더불어, Iterable interface를 상속하였으므로, iterator() 메소드에 override 키워드를 추가합니다.\npublic class ArraySet\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { ... @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new ArraySetIterator(); } 이제, 완전한 Enhanced For-Loop를 사용할 수 있게 되었습니다!\npublic static void main(String[] args) { ArraySet\u0026lt;String\u0026gt; citySet = new ArraySet\u0026lt;\u0026gt;(); citySet.add(\u0026#34;Seoul\u0026#34;); citySet.add(\u0026#34;San Francisco\u0026#34;); citySet.add(\u0026#34;Los Angeles\u0026#34;); citySet.add(\u0026#34;Washington DC\u0026#34;); citySet.add(\u0026#34;Seoul\u0026#34;); for(String str: citySet) System.out.println(str); } 정리해보면, Enhanced For-Loop를 사용하기 위해서 아래 조건들이 만족되어야 합니다.\n해당 클래스가 iterator() Method를 갖고 있는지 해당 클래스의 iterator() Method가 반환하는 Iterator interface가 next/hasNext() 메소드를 갖고 있는지 참고로, Java의 Set Class는 아래 사진 사진과 같은 상속 구조를 갖고 있습니다. Iterable interface로부터 상속을 받기 때문에, enhanced for-loop를 사용할 수 있었던 것이지요.\ninterface간 상속 시, implements가 아닌 extends 키워드를 사용하며, 클래스는 여러 interface를 상속받을 수 있는 반면, class는 단 하나 상속을 받을 수 있습니다.\ntoString ArraySet Object를 그대로 System.out.println 하게 되면 어떤 결과를 얻게 될까요?\npublic static void main(String[] args) { ArraySet\u0026lt;String\u0026gt; citySet = new ArraySet\u0026lt;\u0026gt;(); citySet.add(\u0026#34;Seoul\u0026#34;); citySet.add(\u0026#34;San Francisco\u0026#34;); citySet.add(\u0026#34;Los Angeles\u0026#34;); citySet.add(\u0026#34;Washington DC\u0026#34;); citySet.add(\u0026#34;Seoul\u0026#34;); System.out.println(citySet); } 실행결과 : ArraySet@3fee733d @뒤로 이상한 문자열이 붙은 결과를 얻었습니다.\nObject의 원본 코드를 보면 toString()이라는 메소드 안에서, 클래스 자체의 이름과 hash code라는 것을 합한 결과를 반환하는 것을 알 수 있습니다. @뒤의 문자열은 hash code였던 것이지요.\npublic String toString() { return this.getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(this.hashCode()); } 우리가 원하는 동작은 citySet의 모든 원소들을 콘솔 출력해주는 것입니다.\n이는 toString() 메소드를 오버라이딩함으로 구현할 수 있으며, toString() 메소드는 해당 클래스의 문자열 반환이 요청되었을 때 반환값을 지정할 수 있는 메소드입니다.\nArraySet 클래스 내부에서 toString() 메소드를 구현해 봅시다. @Override public String toString() { String output = \u0026#34;{\u0026#34;; for (int i = 0; i \u0026lt; size; i += 1) { output += items[i].toString() + \u0026#34;,\u0026#34;; } output = output.substring(0, output.length() - 1); output += \u0026#34;}\u0026#34;; return output; } 실행 결과 : {Seoul,San Francisco,Los Angeles,Washington DC} toString() 메소드를 잘 구현해둔다면, 오류 디버깅 시 매우 유용할 것입니다.\nStringBuilder 앞선 구현한 toString()은 사실 상당히 메모리 비효율적입니다.\nString class는 불변(immutable)이기 때문에, + 연산 시 기존 String이 업데이트되는 것이 아니라, 새로운 String이 계속해서 생성됩니다.\n이를 방지하기 위해, StringBuilder를 사용할 수 있습니다.\n@Override public String toString() { StringBuilder output = new StringBuilder(\u0026#34;{\u0026#34;); for (int i = 0; i \u0026lt; size; i += 1) { output.append(items[i].toString()); if(i != size - 1) output.append(\u0026#34;,\u0026#34;); } output.append(\u0026#34;}\u0026#34;); return output.toString(); } “equals()” vs “==” Reference Type의 비교 시 == 연산자는 단순히 메모리 박스의 주소만을 비교하는 것이기 때문에 큰 의미가 없습니다.\nSet\u0026lt;Integer\u0026gt; javaset = Set.of(5, 23, 42); Set\u0026lt;Integer\u0026gt; javaset2 = Set.of(5, 23, 42); System.out.println(javaset == javaset2); \u0026gt; False 실질적으로 두 Set이 같다는 것은, 내부 저장된 원소들이 모두 일치한다는 뜻이지요.\n이러한 작업을 실행하는 것이 equals() 메소드이며, toString() 메소드처럼 이 또한 Object Class 내부에 구현되어 있습니다. 따라서, Override를 통해 우리만의 equals 메소드를 구현할 수 있습니다.\nequals() Method를 ArraySet에 맞게 다시 구현하고 최적화해봅시다. @Override // Object의 메소드를 overriding하기 때문에 동일한 signature를 가져야 합니다. public boolean equals(Object o) { if (o == null) { return false; } // 이 부분이 속도를 최적화해준 부분입니다. // 자기 자신과의 비교는 항상 true가 되기 때문입니다. if (this == o) { return true; } if (this.getClass() != o.getClass()) { return false; } ArraySet\u0026lt;T\u0026gt; other = (ArraySet\u0026lt;T\u0026gt;) o; if (this.size() != other.size()) { return false; } for (T item : this) { if (!other.contains(item)) { return false; } } return true; } 이제 equals()를 통해 ArraySet들 사이의 비교를 손쉽게 할 수 있게 되었습니다 이런 메소드는 한 번 구현해두면 두고두고 사용할 수 있어 매우 편리합니다. ArraySet\u0026lt;Integer\u0026gt; aset = new ArraySet\u0026lt;\u0026gt;(); aset.add(5); aset.add(23); aset.add(42); ArraySet\u0026lt;Integer\u0026gt; aset2 = new ArraySet\u0026lt;\u0026gt;(); aset2.add(5); aset2.add(23); aset2.add(42); // equals System.out.println(aset.equals(aset2)); "
},
{
	"uri": "/kr/lecture7/content1/",
	"title": "Memory Efficiency, Obscurantism, Inheritance, Interface",
	"tags": [],
	"description": "",
	"content": "AList를 통해 배우는 Inheritance와 Interface array를 통해 구현되는 AList에 대한 구현을 계속해봅시다. 현재의 AList는 새로운 item이 계속해서 추가됨에 따라 최대 List 크기를 넘어가게 되면 resize 작업이 요구됩니다. private void resize(int capacity) { int[] a = new int[capacity]; System.arraycopy(items, 0, a, 0, size); items = a; } public void addLast(int x) { if (size == items.length) { resize(size + 100); } items[size] = x; size = size + 1; } 이 작업의 수행 시\n기존 array보다 큰 크기를 갖는 새로운 array를 생성하고 기존 array의 item을 모두 새로운 array에 복사하며 기존 array의 메모리가 반환되며 모든 resize 작업이 완료됩니다. 특히 두번째, 기존 모든 item들이 복사되는 과정에서 오랜 지연이 발생합니다.\n예를 들어, 현재 AList의 size가 100일 때, 1000번의 add가 발생한다면, 약 500,000번의 추가 연산이 요구되며, 이 복잡도는 exponential하게 증가하여 성능에 지대한 영향을 미칩니다.\n출처 : sp21.datastructur.es 이를 방지하기 위해 다음과 같은 해결법을 도입할 수 있습니다.\nresize 시, 배열의 사이즈를 현재 크기의 비례하여 증가시킵니다. 이때, 비례 상수인 REFACTOR를 적절하게 설정하며 저는 2 정도를 선택하였습니다. 참고로, 파이썬의 List가 이러한 구현을 갖는다고 합니다. public void addLast(int x) { if (size == items.length) { resize(size * REFACTOR); } items[size] = x; size = size + 1; } REFACTOR의 경우, 모든 AList가 공유하도록 static으로 설정할 수 있을 것입니다.\nRemove Method Upgrade 현재, AList에 1,000,000개의 item이 있는 상황에서 999,900번의 remove가 실행된 경우 실질적으로 필요한 item은 100개인데 비해, List는 item 1,000,000개에 해당하는 메모리를 계속 붙잡고 있게 됩니다.\n메모리 효율을 위해서 removeLast, removeFirst 메소드를 다음과 같이 개선할 수 있습니다.\nR = (실제 사용중인 size) / (Array의 length)을 정의합니다. (예를 들어 int arr[100] 중 4개만 사용중이면, R=0.04가 됩니다.) 계속해서 remove가 수행되다가 R \u0026lt; 0.25가 되는 순간 array를 resize합니다. public int removeLast() { int x = getLast(); size = size - 1; double R = (double)size / items.length; if ( R \u0026lt; 0.25 \u0026amp;\u0026amp; items.length \u0026gt;= 4 ) resize( (int) (items.length * 0.25)); return x; } 메모리의 효율성과 실행 시간은 trade-off 관계를 갖습니다. 이에 대해서는 이후 강의에서 지속적으로 다루게 됩니다.\nGeneric Programming Upgrade 앞서, int, double 등 다양한 type을 사용할 수 있게 해주는 Generic Programming() 에 대해 살펴보았습니다. 관련하여, 구현 시 발생하는 또다른 문제를 해결해봅시다.\nAList의 Constructor에서는 어떤 타입의 array가 사용될지 모릅니다. 하지만 item을 담는 클래스 변수는 declaration 해주어야 합니다. 이것의 해결을 위해서, AList의 클래스 변수는 일단 Object Type으로 declaration한 뒤, 이후 원하는 타입으로 **Type conversion(Casting)**을 해줍시다. public AList(){ items = (Item[]) new Object[initialSize]; ... 단, items를 object 타입으로 declaration 할 시, 불필요한 메모리 낭비가 생길 수 있습니다. (reference가 하나라도 있을 시, Java의 Garbage Collector가 Object의 메모리를 유지하기 때문입니다.)\n⇒ remove시, 불필요한 item을 null로 변경하도록 하면, 이를 방지할 수 있습니다.\nObscurantism in Java 관련된 개념이 완전히 이해되지 않아 이후 정리될 예정입니다.\nInterface and Implementation Inheritance 구글 맵 예시를 다시 살펴보겠습니다.\n우리 주변에는 헬스장, 병원, 지하철 역 등 다양한 Place들이 있습니다. 추가로, 지하철 역을 Java로 구현해 봅시다. GoogleMaps.java Restaurant.java Station.java public class GoogleMaps { public static void main(String[] args) { Restaurant h = new Restaurant(\u0026#34;Haengwonpark\u0026#34;, 4.5, false); Restaurant m = new Restaurant(\u0026#34;McDonald\u0026#39;s\u0026#34;, 3.5, true); Station s = new Station(\u0026#34;Wangsimni\u0026#34;, 4.1, 836); System.out.println(h.name); System.out.println(h.rating); System.out.println(h.isDineInAllowed); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } public void increaseRating(double rating) { this.rating += rating; } } public class Station { public String name; public double rating; public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } public void increaseRating(double rating) { this.rating += rating; } } Restaurant class와 Station class를 살펴보면, name, rating, constructor등 많은 중복되는 코드를 갖고 있는 것을 확인할 수 있습니다. 불필요한 코드의 중복을 inheritance(상속)을 통해 해결해 봅시다.\nPlace.java Station.java Restaurant.java public class Place { public String name; public double rating; public void increaseRating(double rating) { this.rating += rating; } } public class Station extends Place { public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } } public class Restaurant extends Place { public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } } Station과 Restaurant 클래스가 한층 깔끔해졌습니다.\n개념적으로 상속을 받는 클래스는 Child Class, 상속을 하는 클래스는 Base 혹은 Parent Class라고 합니다. Place Class에 기능을 추가하게 되면, Station과 Restaurant 또한 해당 기능을 사용할 수 있게 됩니다. 장소의 상태를 나타내는 infoString 메소드를 Place에 추가하고 사용해 봅시다.\npublic class Place { public String name; public double rating; public void increaseRating(double rating) { this.rating += rating; } public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34; rating : \u0026#34; + rating; } } Place의 infoString은 name과 rating에 대한 정보만 알 수 있어 Restaurant의 isDineInAllowed나 Station의 stopID와 같은 정보가 누락됩니다.\n따라서, Child Class에서도 자기 나름의 infoString 메소드를 구현하게 되며, 이것을 메소드 오버라이딩 (Method Overriding) 이라고 부릅니다.\nRestaurant.java Station.java public class Restaurant extends Place { public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } /* Method Overriding in Here! */ public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, isDineInAllowed : \u0026#34; + isDineInAllowed; } } public class Station extends Place { public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } /* Method Overriding in Here! */ public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, stopID : \u0026#34; +stopID; } } 마지막으로, 두 Class 모두 Place를 상속 받았기 때문에, 아래와 같은 Advanced For-loop을 사용할 수 있습니다. For-loop을 순회하며 Place가 Restaurant면 isDineInAllowed를, Station이면 stopID를 추가하여 완성된 String을 반환합니다.\nGoogleMaps.java 실행 결과 public class GoogleMaps { public static void main(String[] args) { Restaurant h = new Restaurant(\u0026#34;Haengwonpark\u0026#34;, 4.5, false); Restaurant m = new Restaurant(\u0026#34;McDonald\u0026#39;s\u0026#34;, 3.5, true); Station s = new Station(\u0026#34;Wangsimni\u0026#34;, 4.1, 836); Place [] p = new Place[3]; p[0] = h; p[1] = m; p[2] = s; for(Place elem : p) System.out.println(elem.infoString()); } } Place - name : Haengwonpark, rating : 4.5, isDineInAllowed : false Place - name : McDonald\u0026#39;s, rating : 3.5, isDineInAllowed : true Place - name : Wangsimni, rating : 4.1, stopID : 836 Overriding은 method name, parameter type, return type등 “signature” 가 완전히 일치해야 하며, 메소드의 철자 하나만 달라져도 Java는 완전히 다른 Method로 인식합니다.\nmethod 상단에 @Override 키워드를 추가하면 컴파일러가 Overriding을 검사하기 때문에 이러한 실수를 방지할 수 있습니다.\nRestaurant.java Station.java public class Restaurant extends Place { public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } @Override public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, isDineInAllowed : \u0026#34; + isDineInAllowed; } } public class Station extends Place { public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } @Override public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, stopID : \u0026#34; +stopID; } } Java interface Java는 여러 Class로부터의 상속 (다중 상속)을 허용하지 않습니다. 하지만 Interface라는 것을 통해 다중 상속와 유사한 구현을 허용하고 있으며, 이는 C++의 추상 클래스와 유사한 개념을 갖습니다.\nIntelliJ에서 Interface는 다음과 같이 생성합니다.\n일전 infoString 메소드를 interface로 구현하고자 Stringable이라는 interface를 구현해봅시다.\npublic interface Stringable { String infoString(); } 이제, infoString은 Stringable에게 위임하고, Restaurant, Station과 더불어 Cafe 라는 Class를 추가로 구현하고자 합니다.\npublic class Cafe implements Stringable{ public String name; public double rating; public Cafe(String name, double rating){ this.name = name; this.rating = rating; } @Override public String infoString(){ return \u0026#34;Cafe - name: \u0026#34; + this.name + \u0026#34;, rating: \u0026#34; + this.rating; } } Cafe 코드에서 볼 수 있듯이, interface로부터 상속을 받는 키워드는 implements이며, 상속받은 Class는 interface의 모든 method를 반드시 구현해야 합니다.\ninfoString에 대한 Overriding이 없으면 Cafe Class 자체가 컴파일되지 않습니다.\npublic class Cafe implements Stringable{ ... @Override public String infoString(){ return \u0026#34;Cafe - name: \u0026#34; + this.name + \u0026#34;, rating: \u0026#34; + this.rating; } } 참고로, 일전 언급되었지만 Class는 interface와 다른 Class로부터 동시에 상속을 받을 수 있습니다.\n정리하자면, Class는 여러 interface들을 상속받을 수 있지만, 부모 Class는 단 하나만 가질 수 있습니다. public class Station extends Place implements Stringable { ... public class Restaurant extends Place implements Stringable { ... 현재 Class들 사이의 관계를 정리해보자면 다음과 같습니다.\nPlace ⇒ Restaurant Place ⇒ Station Stringable ⇒ Station, Restaurant, Cafe 이러한 설계를 어떻게 효울적으로 할 것인지에 대해서 자주 사용되는 패턴을 집대성한 “디자인 패턴” 이라는 방법론이 있습니다. (현재 공부중에 있으며, 기회가 되면 포스팅도 진행하겠습니다.)\ninheritance vs interface Class를 통한 상속과, Interface는 다음과 같이 여러 차이점을 갖고 있습니다. 주요한 특징을 몇가지 살펴봅시다.\ninterface는 그 자체로는 instantiation이 불가하며, 따라서 constructor를 가질 수 없습니다. Interface의 constructor를 구현하려 하면 IntelliJ에서 아래와 같이 에러를 감지할 것입니다. interface안에는 변수를 설정할 수는 있지만 반드시 interface내부에서 instantiation이 이루어져야 합니다. 상속받은 다른 Class는 이 값을 바꿀 수 없으며, 따라서 사실상 변수보다는 상수에 가깝습니다. public interface Stringable { String infoString(); int constVar = 3; } interface로부터 상속을 받았다면 interface내의 모든 메소드를 구현해야 합니다. "
},
{
	"uri": "/kr/lecture7/content2/",
	"title": "Overriding vs Overloading",
	"tags": [],
	"description": "",
	"content": "inheritance와 interface를 통해 코드를 간소화할 수 있다는 것을 알게 되었습니다.\nAList와 SList의 코드를 다시 살펴보면, 대부분의 메소드가 중복되고 있음을 발견할 수 있는데요, 상속을 통해 이러한 중복을 제거할 수 있을 것입니다.\nAList SLList public class AList\u0026lt;Item\u0026gt;{ public AList() public void insert(Item x, int position) public void addFirst(Item x) public void addLast(Item i) public Item getFirst() public Item getLast() public Item get(int i) public int size() public Item removeLast() } public class SList\u0026lt;Item\u0026gt;{ public SLList() public SLList(Item x) public void insert(Item item, int position) public void addFirst(Item x) public void addLast(Item x) public Item getFirst() public Item getLast() public Item get(int i) public int size() public Item removeLast() } 하지만, 상황에 따라, 불가피하게 input parameter가 달라져야 하는 경우가 있습니다.\n아래 예시를 살펴봅시다, 완전히 같은 코드임에도 불구하고, input parameter 타입이 다르기 때문에 Overriding이 불가합니다.\nAList SLList public static String longest(AList\u0026lt;String\u0026gt; list) { int maxDex = 0; for (int i = 0; i \u0026lt; list.size(); i += 1) { String longestString = list.get(maxDex); String thisString = list.get(i); if (thisString.length() \u0026gt; longestString.length()) { maxDex = i; } } return list.get(maxDex); } public static String longest(SLList\u0026lt;String\u0026gt; list) { int maxDex = 0; for (int i = 0; i \u0026lt; list.size(); i += 1) { String longestString = list.get(maxDex); String thisString = list.get(i); if (thisString.length() \u0026gt; longestString.length()) { maxDex = i; } } return list.get(maxDex); } 이러한 경우, Method Overloading 을 사용합니다.\nOverloading은 같은 이름을 갖는 메소드를 여러개 구현한다는 면에서 오버라이딩과 유사하지만, signature의 차이를 허용한다는 점, 같은 클래스 안에서 구현 가능하다는 차이점을 갖습니다.\n간단히 말해 같은 signature를 사용하면 overriding하고 있다고 볼 수 있습니다. 단, 철자 하나라도 차이가 나면 overriding에서 overloading으로 전환되기 때문에 @Override 키워드를 Method 상단에 추가한다는 것도 확인한 바 있었습니다.\nsignature에 해당하는 요소들은 name, arguments, return type이 있었습니다.\nOverloading의 단점은 관리가 힘들다 는 것입니다. 예를 들어, longest의 로직을 바꾸고자 하는 경우, AList 타입을 input으로 받는 longest와 SLList 타입을 input으로 받는 longest 모두를 수정해야 합니다.\nHypernyms, Hyponyms, and Interface Inheritance “Dog은 Canine이다” 라는 말은 성립하지만, “Dog은 Canine이다” 라는 말은 Fox, Coyote등의 반례가 존재하기 때문에 성립할 수 없습니다.\n이러한 Class들 사이의 상속 관계를 is-a 관계라고 합니다.\nDog is-a Canine은 참이지만, Animal is-a Dog은 불가하지요.\n위 그림을 통해 살펴보면, 상위 클래스 is-a 하위 클래스라는 관계는 성립하지 않는다는 것을 알 수 있습니다.\n강의에서는 Hypernym이라는 단어로 상위 개념을, Hyponym이라는 단어로 하위 개념을 지칭하고 있습니다.\nAList와 SList의 상위 개념이 되는 ListOOP interface를 구현해봅시다. public interface ListOOP\u0026lt;Item\u0026gt; { public void addFirst(Item x); public void addLast(Item y); public Item getFirst(); public Item getLast(); public Item removeLast(); public Item get(int i); public void insert(Item x, int position); public int size(); } AList와 SList는 모두 ListOOP interface에서 implements 받으며, AList는 ListOOP 내에 있는 모든 Method를 구현해야 합니다. (Interface 상속의 특징이었지요.)\npublic class AList\u0026lt;Item\u0026gt; implements ListOOP\u0026lt;Item\u0026gt;{ ... public void addLast(Item x) { ... longest Method를 ListOOP내에서 declaration 한 결과, 이제 overloading을 하지 않아도, longest Method를 SLList, AList 모두에 사용 가능해졌습니다.\npublic static String longest(ListOOP\u0026lt;String\u0026gt; list) { int maxDex = 0; for (int i = 0; i \u0026lt; list.size(); i += 1) { String longestString = list.get(maxDex); String thisString = list.get(i); if (thisString.length() \u0026gt; longestString.length()) { maxDex = i; } } return list.get(maxDex); } Overriding의 원리 아래 예시에서, someList.addFirst를 호출하면, SLList의 addFirst 메소드가 호출될 것입니다.\n이러한 실행이 가능한 이유는 무엇일까요?\npublic static void main(String[] args) { ListOOP\u0026lt;String\u0026gt; someList = new SLList\u0026lt;String\u0026gt;(); someList.addFirst(\u0026#34;elk\u0026#34;); } \u0026ldquo;SLList is-a ListOOP\u0026rdquo; 라는 관계를 기억하시나요? 더불어, reference type은 실질적인 메모리를 갖는 것이 아닌, 해당 메모리의 주소를 가리키는 변수라고 하였습니다. 따라서, ListOOP 타입의 변수는, SLList 타입을 갖는 메모리 주소를 가질 수 있게 됩니다. 하지만, ListOOP is-not-a SLList이기 때문에 이 반대는 성립하지 않습니다. Implementation Inheritance: Default Methods 본디, interface는 Method의 declaration만을 허용하지만, default 키워드를 추가하면, Method의 구현이 가능해집니다.\npublic interface Stringable { default String infoString(){ return \u0026#34;Default String\u0026#34;; } } default Method는 하위 클래스에서 다시금 Overriding이 가능합니다. 아래 print의 경우, get을 사용하는 것은 SLList에게 매우 비효율적인 방식이기 때문에, SLList Class에서 별도로 Overriding을 구현해 주었습니다.\npublic interface ListOOP\u0026lt;Item\u0026gt; { ... default public void print() { for (int i = 0; i \u0026lt; size(); i += 1) { System.out.print(get(i) + \u0026#34; \u0026#34;); } System.out.println(); } } public interface SLList\u0026lt;Item\u0026gt; implements ListOOP { @Override public void print() { for (Node p = sentinel.next; p != null; p = p.next) { System.out.print(p.item + \u0026#34; \u0026#34;); } System.out.println(); } } Static and Dynamic Type, Dynamic Method Selection compile-time type이라고도 불리는 static type은 변수의 declaration시 설정되는 타입으로, 절대 바뀌지 않습니다. (일반적으로 변수 선언 시 지정되는 타입이 여기 해당합니다.) dynamic type은 변수의 instantiation 시(new 사용 시) 설정되는 타입으로, 해당 변수가 실질적으로 가리키는 object의 타입입니다. 예시를 통해 static type / dynamic type에 대한 이해를 해봅시다. public static void main(String[] args) { LivingThing lt1; // lt1의 static type은 LivingThing lt1 = new Fox(); // lt1의 dynamic type은 Fox Animal a1 = lt1; // a1의 static type은 Animal Fox h1 = new Fox();// h1의 static type은 Fox, dynamic type은 Fox lt1 = new Squid(); // lt1의 dynamic type은 Squid } 출처 : sp21.datastructur.es static type은 declaration 시 결정되어 바뀌지 않는 반면, lt1에서 볼 수 있듯이 dynamic type은 변경이 가능합니다.\n일전 예시에서도, someList의 static type은 ListOOP였지만, dynamic type은 SLList가 되었습니다.\npublic static void main(String[] args) { ListOOP\u0026lt;String\u0026gt; someList = new SLList\u0026lt;String\u0026gt;(); someList.addFirst(\u0026#34;elk\u0026#34;); } Method의 호출 시에는 dynamic type의 Method가 호출되며, 이를 dynamic method selection 이라고 부릅니다. Dynamic Method Selection Puzzle: Try to Predict the Results 아래 코드를 실행하면 어떤 결과를 얻게 될까요?\nAnimal.java Dog.java DogLauncher.java 실행결과 public interface Animal { default void greet(Animal a) { System.out.println(\u0026#34;hello animal\u0026#34;); } default void sniff(Animal a) { System.out.println(\u0026#34;sniff animal\u0026#34;); } default void praise(Animal a) { System.out.println(\u0026#34;u r cool animal\u0026#34;); } } public class Dog implements Animal { @Override public void sniff(Animal a) { System.out.println(\u0026#34;dog sniff animal\u0026#34;); } public void praise(Dog a) { System.out.println(\u0026#34;u r cool dog\u0026#34;); } } public class DogLauncher { public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); a.sniff(d); d.praise(d); a.praise(d); } } hello animal dog sniff animal u r cool dog u r cool animal 왜 이런 결과를 얻었을까요?\nDynamic Method Selection의 두가지 규칙을 생각하면서 코드를 해석해봅시다.\nRule 1 : 호출되는 Method의 Signature는 오로지 Complie Time에 결정되며, 따라서 Static Type을 사용하게 된다. Dog launcher의 코드를 통해 Rule 1을 적용해봅시다. (코드의 주석으로 Signature를 적어두었습니다.) public class DogLauncher { public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); // greet(Animal a) a.sniff(d); // sniff(Animal a) d.praise(d); // praise(Dog a) a.praise(d); // praise(Animal a) } } a의 static type은 Animal이므로, 오로지 Animal 클래스 내의 Method만 사용됩니다.\nRule 2 : dynamic type을 갖는 object의 Method 호출 시, Complie Time에 결정된 signature와 정확히 일치하는 Method가 호출된다. Dog launcher의 코드를 통해 Rule 2를 적용해봅시다. public class DogLauncher { public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); // greet(Animal a) =\u0026gt; Dog의 greet(Animal a) 호출 a.sniff(d); // sniff(Animal a) =\u0026gt; Dog의 sniff(Animal a) 호출 d.praise(d); // praise(Dog a) =\u0026gt; Dog의 praise(Dog a) 호출 a.praise(d); // praise(Animal a) =\u0026gt; Dog의 praise(Animal a) 호출 } } 아마 혼란스러운 부분은 제일 마지막 코드가 아닐까 싶습니다.\n이때의 praise는 Dog.praise()가 아닌, Animal.praise()가 호출됩니다. a의 dynamic type이 Dog일지라도, praise(Animal a)는 Dog클래스 내부에 존재하지 않습니다. 따라서 Dog is-a Animal에 따라 Animal.praise()가 호출됩니다. 결국, a의 static type이 Animal이며, praise(Animal a)가 Dog 내부에 Override되어있지 않아 발생하는 결과입니다. 만약 praise(Animal a)를 Override 한다면, 의도한 결과를 얻게 됩니다.\nAnimal.java Dog.java 실행결과 public interface Animal { default void greet(Animal a) { System.out.println(\u0026#34;hello animal\u0026#34;); } default void sniff(Animal a) { System.out.println(\u0026#34;sniff animal\u0026#34;); } default void praise(Animal a) { System.out.println(\u0026#34;u r cool animal\u0026#34;); } } public class Dog implements Animal { @Override public void sniff(Animal a) { System.out.println(\u0026#34;dog sniff animal\u0026#34;); } @Override public void praise(Animal a) { System.out.println(\u0026#34;u r cool dog\u0026#34;); } } hello animal dog sniff animal u r cool dog u r cool dog "
},
{
	"uri": "/kr/lecture6/content1/",
	"title": "SLList Upgrade, DLLs and Arrays",
	"tags": [],
	"description": "",
	"content": " SLList Upgrade DLLs and Arrays 앞선 SLList의 단점들을 하나씩 개선해 봅시다.\nsize() 개선 기존 IntNode에서는 전체 List의 크기를 알아내기 위해 모든 List를 순회해야 했습니다. 이와 달리, SLList에서는 전체 List의 길이를 보관하는 별도의 member variable을 만듭니다. 이는 SLList의 초기 생성 시에는 1이 될 것이며, Node를 추가할 때마다 1씩 증가하게 됩니다. public class SLList { private IntNode first; private int size; public SLList() { first = null; size = 0; } public void addFirst(int x) { ... size = size + 1; } ... addLast 개선 현 addLast의 문제는 비어있는 SLList에 addLast를 수행할 시, p.next가 null.next가 되어 오류가 발생한다는 것입니다. public class SLList { private IntNode first; private int size; public SLList() { first = null; size = 0; } public void addLast(int x) { size += 1; IntNode p = first; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } ... 이러한 오류를 방지하기 위해 if를 추가할 수 있지만, 첫 시작에 대한 조건을 추가하기 시작하면, 다른 method에서도 계속해서 추가 조건이 붙는 상황이 발생하게 됩니다. public void addLast(int x) { size += 1; if (first == null) { first = new IntNode(x, null); return; } IntNode p = first; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } 본질적인 해결을 위해서 sentinal node라는 개념을 통해 예외를 제거하고, 모든 상황을 동일하게 만들 수 있습니다.\n수정되는 코드를 먼저 살펴보겠습니다. private IntNode sentinel; private int size; public SLList() { sentinel = new IntNode(63, null); size = 0; } public SLList(int x) { sentinel = new IntNode(63, null); sentinel.next = new IntNode(x, null); size = 1; } public void addFirst(int x) { sentinel.next = new IntNode(x, sentinel.next); size = size + 1; } public void addLast(int x) { size = size + 1; IntNode p = sentinel; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } ... List의 크기와 상관없이 (아무 item이 없더라도), sentinal이 항상 존재하며, sentinal 또한 하나의 Node이기에 item을 갖게 됩니다. 하지만 sentinal의 item은 사용되지 않으므로 어떠한 값을 가지던 상관없습니다. 출처 : https://sp21.datastructur.es/ Part 2: DLLs and Arrays SLList의 또 다른 문제점은, addFirst와 addLast에 걸리는 시간이 큰 차이를 갖는다는 점입니다. addLast의 경우, while문을 통해 전체 list의 마지막으로 접근해야 비로소 add가 가능한 반면, addFirst는 first를 통해 바로 추가가 가능합니다. public void addFirst(int x) { sentinel.next = new IntNode(x, sentinel.next); } ... public void addLast(int x) { size += 1; IntNode p = sentinel; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } 이를 해결하기 위해서, 전체 list의 마지막을 가리키는 last라는 새로운 IntNode 타입의 member를 추가해봅시다. last를 별도 저장하고 있기 때문에, addLast의 실행 시간을 단축시킬 수 있으며, addLast 될 때마다 이를 갱신합니다. private IntNode sentinel; private IntNode last; private int size; ... public SLList() { sentinel = new IntNode(63, null); last = sentinel; size = 0; } public SLList(int x) { sentinel = new IntNode(63, null); sentinel.next = new IntNode(x, null); last = sentinel.next; size = 1 } public void addLast(int x) { size = size + 1; IntNode p = last; p.next = new IntNode(x, null); last = p.next; } ... last member를 추가하여 addLast()가 무척 빨라졌습니다.\n하지만, removeLast가 여전히 느린 상황입니다. 마지막 Node를 지우게 되면, 그 이전 Node를 새롭게 last로 갱신해야 하는데, 현재의 SLList는 한 방향으로만 서로를 연결하고 있어 last ⇒ first 방향으로의 순서는 곧바로 알 수 없습니다. 출처 : https://sp21.datastructur.es/ 새로운 구조의 Linked List를 통해 이 문제를 해결해봅시다.\nDoubly Linked List (DLL) Node간 next와 prev 관계를 모두 저장하는 doubly linked list를 구현해 봅시다. doubly linked list를 구현하는 두가지 방식이 있습니다. 1. sentinal node는 item과 무관하게 List의 첫 시작을 가리키는 node였습니다. back sentinal을 두게 하여 마지막 Node의 위치도 기억하도록 할 수 있습니다.\n2. front / back sentinal을 두는 것은 코드 구현을 복잡하게 만들고, 사용되지 않는 불필요한 부분이 생기도록 만듭니다. 이를 해결하기 위한 방법으로, sentinal의 next는 첫번째 Node를, sentinal의 prev는 마지막 Node를 바라보게 하는 circular sentinal을 구현할 수 있습니다.\n출처 : https://sp21.datastructur.es/ 구현 코드는 과제와 관련되어 있으므로, 추후 추가 예정입니다.\n"
},
{
	"uri": "/kr/lecture5/content1/",
	"title": "PARAMETER PASSING, LISTS, ARRAYS",
	"tags": [],
	"description": "",
	"content": " PARAMETER PASSING Instantiation of Arrays Linked List in Java 지난 시간, primitive type과 reference type에 대해서 배워보았습니다.\n이번에는 이들이 method의 매개변수로 전달되는 과정을 살펴봅시다.\n퀴즈 - 아래 코드에서, walrus와 x중 어떠한 값이 변경되고 유지될까요?\nPollQuestions.java 실행결과 public class PollQuestions { public static void main(String[] args) { Walrus walrus = new Walrus(3500, 10.5); int x = 9; doStuff(walrus, x); System.out.println(walrus); System.out.println(x); } public static void doStuff(Walrus W, int x) { W.weight = W.weight - 100; x = x - 5; } ... weight: 3400, tusk size: 10.50 9 primitive type은 method의 매개변수로 전달되면서 새로운 변수가 생성되고 복사되는 과정이 진행됩니다. 반면, reference type은 method의 매개변수로 전달되어도 해당 변수가 가리키고 있던 실제 값은 변하지 않기 때문에 doStuff안에서의 작업에 영향을 받습니다. 이 과정을 시각화해보면 다음과 같습니다.\nInstantiation of Arrays array는 reference type이기 때문에 array를 declaration한다는 것은 그저 pointer를 만들어준다는 뜻이 됩니다. array를 instantiation하고 assignment해야 비로소 의미 있는 값을 가리키는 array가 됩니다. int[] my_arr; // Nothing :( int[] a = new int[]{0, 1, 2, 95, 3}; a = new int[]{2, 3, 4, 5}; 위 코드에서, a 자체는 pointer이기 때문에 a가 가리키고 있는 값은 얼마든지 바꿀 수 있습니다. 마지막 라인과 같이 값의 변경이 일어난 경우, 기존 a가 가리키던 값은 더이상 사용되지 않는 메모리가 되며, Java는 이러한 불필요한 메모리를 똑똑하게 관리해주는 garbage collector를 갖고 있습니다. IntList and Linked Data Structures Array vs. List array와 list는 모두 동일한 type의 item들을 저장한다는 공통점이 있지만, 아래와 같은 차이점들을 갖습니다.\narray는 크기가 고정되어 있으며, initialization시 크기를 지정해주어야 합니다. (linked) list는 크기가 고정되어 있지 않아 initialization시 크기를 지정해줄 필요가 없습니다. 코드 구현을 시작하면서, Int 타입을 담는 Linked List, IntList를 구현해봅시다.\nIntList는 연쇄적으로 얽혀 있는 사슬 구조를 가지며, 한 방향으로 계속 길어집니다. 때문에, item을 담는 first와, 다음 IntList 가리키는 rest를 member로 갖습니다. public class IntList { public int first; public IntList rest; public IntList(int f, IntList r) { first = f; rest = r; } ... IntList의 크기를 알아내기 위해서는 rest가 더이상 존재하지 않는 끝지점까지 IntList를 순회하면서 그 개수를 counting 해야 합니다.\n이를 구현하는 방식으로 1. 재귀함수 / 2. while문을 사용하는 두가지 접근을 취해봅시다.\n재귀함수 구현 while문 구현 public int size() { if(rest == null){ return 1; } return 1 + rest.size(); } public int iterativeSize() { IntList l = this; int count = 1; while(l.rest != null){ l = l.rest; count++; } return count; } 다음으로, 특정 index의 값을 반환하는 get 함수를 구현해봅시다.\n주어진 index만큼 IntList를 순회하고 원하는 위치에서의 값을 반환합니다. get 또한 1. 재귀함수 / 2. while을 통한 구현이 가능합니다. 재귀함수 구현 while문 구현 public int get(int i) { if (i == 0) { return first; } return rest.get(i - 1); } public int get(int i) { IntList l = this; while(i \u0026gt; 0){ l = l.rest; i--; } return l.first; } 지금까지 구현된 method를 실행하는 main 함수를 작성해봅시다.\nIntList.java 실행결과 public static void main(String[] args) { IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); System.out.println(L.iterativeSize()); System.out.println(L.size()); System.out.println(L.get(1)); } 3 3 10 IntList 개선하기 기존의 liIntList는 새로운 node를 추가하고자 할 시, .rest를 반복해서 붙여줘야 했습니다. 이에 따라 사용자가 마음대로 IntList의 순서를 바꿀 수 있게 되는 위험성을 내포하게 됩니다.\nIntList my_list = new IntList(1, null); my_list.rest = new IntList(2, null); my_list.rest.rest = new IntList(3, null); IntList의 단점을 극복하는 SLList를 구현해봅시다.\nSLLists는 Node와 Linked List를 클래스 단위에서 구분합니다. 가장 앞에 등장하는 IntNode를 first로 지정하고, 새로운 Node가 추가될 때마다 first를 갱신합니다. 따라서 가장 먼저 추가한 Node는 Linked List 상에서 가장 마지막에 위치하게 됩니다. public class SLList { private static class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; } } public IntNode first; public SLList(int x){ first = new IntNode(x, null); } ... SLList와 IntList를 비교해봅시다.\nSLList는 초기에만 new 키워드가 사용되었습니다. 이는 곧 새로운 object의 생성은 SLList에서 알아서 처리해준다는 뜻이 됩니다. 이를 통해 사용자의 실수가 줄어들 것이며, 사용자는 Linked List의 생성자에 대한 정보는 일절 몰라도 됩니다. 단지 addFirst()만 사용할 줄 알면 됩니다. SLList IntList SLList L = new SLList(15); L.addFirst(10); L.addFirst(5); int x = L.getFirst(); IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); int x = L.first; "
},
{
	"uri": "/kr/lecture4/content1/",
	"title": "Selection Sort, A Simple JUnit test, Testing Philosophy",
	"tags": [],
	"description": "",
	"content": " Selection Sort A Simple JUnit test Testing Philosophy 내가 작성하는 모든 코드가 완벽하리라 보장할 수는 없을 것입니다. 이를 위해 다양한 test 코드를 만들고 이를 통해 잘못된 로직을 수정하는 방식을 사용하여 코드의 안정성을 높일 수 있습니다.\nSelection Sort 구현 String array가 주어졌을 때, 알파벳 순으로 정렬된 array를 반환하는 sort 코드를 작성해봅시다.\n예를 들어, {”i”, “am”, ”a”, “student”}라는 array는 {”a”, “am”, “i”, “student”}가 될 것입니다. sort method를 구현하기 전, 테스트 코드를 작성해봅시다. 잘못된 결과가 발견될 경우, println을 통해 콘솔 출력을 해줍니다. public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); for (int i = 0; i \u0026lt; input.length; i++){ if(!input[i].equals(expected[i])){ System.out.println(\u0026#34;Error in index\u0026#34; + i + \u0026#34; expected : \u0026#34; + expected[i] + \u0026#34;/ actual : \u0026#34; + input[i]); } } } ... public static void main(String[] args) { testSort(); } String의 비교는 == 연산자가 아닌, .equals() method를 사용합니다.\n이렇게 모든 element를 비교하거나, 콘솔 출력을 하는 코드를 작성하는 것은 매우 비효율적이고 반복적입니다.\n따라서, 우리는 JUnit이라는 유용한 툴을 사용하고자 합니다.\n프로그램의 최상단에 junit 패키지를 import한 뒤, 원하는 method를 사용하면 됩니다. 이번 예시에 적합한, 두 array가 동일한지 비교해주는 assertArrayEquals라는 method를 사용하겠습니다. import static org.junit.Assert.*; public class TestSort { public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); assertArrayEquals(expected, input); } ... Sort의 Test 코드를 작성하였으므로, 이제 본격적인 sort 알고리즘을 구현해봅시다. 구현할 sort 알고리즘은 selection sort 알고리즘입니다.\n전체 array에서 가장 작은 item을 찾아 첫번째 위치로 변경합니다. array의 첫번째 item은 이미 가장 작은 item이니, 이를 제외한 두번째 item부터 다시 가장 작은 item을 찾습니다. 위 작업을 모든 array가 sorting 완료될 때까지 반복합니다. 출처 : https://www.hackerearth.com selection sort를 잘 살펴보면, 특정 array 내에서 가장 작은 item을 찾아내는 과정이 반복됩니다.\n이를 helper method로 분리할 수 있고, 이렇게 분리된 method를 위해서 다시 test code를 작성할 수 있습니다.\n출처 : sp21.datastructur.es 가장 작은 item을 찾는 findSmallest method와 이를 위한 test code를 작성해봅시다.\nTestSort.java Sort.java public void testFindSmallest() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; assertEquals(1, Sort.findSmallest(input, 0)); String[] input2 = {\u0026#34;pizza\u0026#34;, \u0026#34;hamburger\u0026#34;, \u0026#34;pork\u0026#34;, \u0026#34;sushi\u0026#34;, \u0026#34;chicken\u0026#34;, \u0026#34;pasta\u0026#34;}; assertEquals(4, Sort.findSmallest(input2, 0)); } public static int findSmallest(String[] x, int startIndex) { int smallestIndex = startIndex; for (int i = startIndex + 1; i \u0026lt; x.length; i += 1) { if (x[i].compareTo(x[smallestIndex]) \u0026lt; 0) { smallestIndex = i; } } return smallestIndex; } 문자열의 비교를 위해 compareTo()를 사용해야 합니다.\ncompareTo() 이 method는 두 문자열을 비교하여 상황에 따라 양수, 0, 음수를 반환합니다. 해당 String이 매개변수로 주어진 String보다 작다면, 음수를 반환하여, 이에 따라 가장 작은 item의 index를 업데이트합니다. 다음으로, array의 두 item의 위치를 바꿔주는 swap 함수와 test 코드를 구현합시다.\nTestSort.java Sort.java public void testSwap() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; Sort.swap(input, 1, 2); String[] expected = {\u0026#34;banana\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; assertArrayEquals(expected, input); } public static void swap(String[] x, int a, int b) { String c = x[a]; x[a] = x[b]; x[b] = c; } 마지막으로, 최종 sort method와 test 코드를 작성합니다.\nTestSort.java Sort.java public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); assertArrayEquals(expected, input); } public static void sort(String[] x) { sort(x, 0); } private static void sort(String[] x, int startIndex) { if (startIndex \u0026gt;= x.length - 1) { return; } int smallestIndex = findSmallest(x, startIndex); swap(x, startIndex, smallestIndex); sort(x, startIndex + 1); } sort 알고리즘은 반복적 실행이 필요하기 때문에 재귀 함수를 사용하는 helper method를 구현하였습니다. 더불어, helper method와 원본 함수가 동일한 이름을 갖고 있으며, 이는 method overloading이 사용되었음을 알 수 있습니다. 이렇게 test 코드를 잘 작성해두면 여러 이점이 있습니다.\n협업 시 다른 프로그래머가 코드를 작업하더라도, test를 잘 통과하는지만 살펴보면 되기 때문에 효율적이게 됩니다. 코드를 나누어 test하기 때문에 전체 실행 시간이 적어지고, 코드 작성의 뼈대를 구축할 수 있게 됩니다. 더불어, 코드를 모두 작성한 뒤, 기능에 영향을 미치지 않는 선에서 불필요한 변수의 선언, 코드의 중복을 제거하는 것을 refactoring이라고 합니다. 추가로, org.junit.Test를 import 하고 @Test를 test code 위에 붙여주면, main 함수 없이도 특정 test code를 실행할 수 있게 됩니다.\nimport org.junit.Test; import static org.junit.Assert.*; public class TestSort { @Test public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); assertArrayEquals(expected, input); } } "
},
{
	"uri": "/kr/lecture3/content1/",
	"title": "Class Defining, Instantiating, Array of Objects, Static vs Non-static",
	"tags": [],
	"description": "",
	"content": " Java 클래스의 Defining과 Instantiating Arrays of Objects static vs non-static object instantiation 클래스에는 다양한 instance method, variable들이 존재합니다. 따라서, object의 생성 시, 이 member들을 초기화해주는 작업이 필요하며, 이를 object instantiation이라고 부릅니다.\nobject instantiation을 하는 여러 방법이 있지만, 클래스 내부에서 constructor를 만들어줌으로 이를 수행할 수 있습니다.\npublic class Dog { public int weightInPounds; /** One integer constructor for dogs. */ public Dog(int w) { weightInPounds = w; } public void makeNoise() { if (weightInPounds \u0026lt; 10) { System.out.println(\u0026#34;yip!\u0026#34;); } else if (weightInPounds \u0026lt; 30) { System.out.println(\u0026#34;bark.\u0026#34;); } else { System.out.println(\u0026#34;woooof!\u0026#34;); } } } constructor의 특징\n리턴 타입이 없고, 클래스와 같은 이름을 갖는 method입니다. object가 new 키워드를 통해 생성될 때 실행됩니다. 그 밖의 함수들은 static, 혹은 non-static method가 됩니다. 일전 살펴본 Dog 클래스를 main에서 사용해봅시다. 코드 주석으로 declaration, instantiation, assignment에 대한 설명이 추가되어 있습니다.\npublic class DogLauncher { public static void main(String[] args) { Dog smallDog; // declaration: 메모리에 Dog 변수를 할당 new Dog(20); // Dog 클래스를 Dog object로 instantiation smallDog = new Dog(5); // assignment : instantiation된 object를 변수에게 할당 Dog hugeDog = new Dog(150); smallDog.makeNoise(); hugeDog.makeNoise(); } } 위 코드 new Dog(20);의 경우, instantiation는 되지만 해당 assignment가 되지 않아, 이 dog은 실제로는 사용할 수 없으므로 사라지게 됩니다. 더불어, Dog hugeDog = new Dog(150);의 경우, declaration instantiation assignment가 한 줄에서 모두 실행되는 형태를 갖습니다. 그렇다면, declaration과 assignment를 동시에 실행하는 것과 분리하는 것의 차이는 무엇일까요?\n배가 고프다면 맛있는 식당으로, 그렇지 않다면 평범한 식당으로 가는 로직을 구현해 봅시다.\npublic class GoogleMaps { public static void main(String[] args) { Restaurant m = new Restaurant(\u0026#34;McDonald\u0026#39;s\u0026#34;); m.rating = 3.9; m.isDineInAllowed = true; Restaurant w = new Restaurant(\u0026#34;Wangsibli\u0026#34;); w.rating = 5.0; w.isDineInAllowed = true; boolean hungry = false; if(hungry) { Restaurant r = new Restaurant(\u0026#34;HangWonPark\u0026#34;); } else { Restaurant r = new Restaurant(\u0026#34;ShinSoJae\u0026#34;); } System.out.println(r.name); } } 위 코드에서 r은 if{ }문 안에서 생성되었으므로, 괄호를 벗어나게 되면 사라지게 됩니다. 때문에, System.out.println(r.name);는 실행될 수 없습니다. (이를 변수의 스코프 라고 부릅니다.)\ndeclaration과 assignment를 분리하면 우리가 원하던 기능을 구현할 수 있고, 유연한 프로그래밍이 가능해집니다. 더불어, declaration과 instantiation을 한 라인에 작성하므로 코드의 양을 줄일 수 있고, 실수도 줄일 수 있습니다. ... boolean hungry = false; Restaurant r; if(hungry) { r = new Restaurant(\u0026#34;HangWonPark\u0026#34;); } else { r = new Restaurant(\u0026#34;ShinSoJae\u0026#34;); } System.out.println(r.name); } } Arrays of Objects 자바에서는 array 또한 object입니다. 따라서 array도 instantiation을 필요로 합니다.\nDog[] dogs = new Dog[2]; dogs[0] = new Dog(8); dogs[1] = new Dog(20); dogs[0].makeNoise(); 위 예시에서는 object의 array를 생성하고 있으므로, array의 각 object들 또한 instantiation을 필요로 합니다.\n만약 Dog의 Constructor에 console output을 추가한 뒤 Dog array를 declaration하면 어떤 결과를 얻을까요?\nDog.java DogLauncher.java 실행 결과 public class Dog { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; /** One integer constructor for dogs. */ public Dog(int w) { weightInPounds = w; System.out.println(\u0026#34;New Dog created!!\u0026#34;); } public void makeNoise() { if (weightInPounds \u0026lt; 10) { System.out.println(\u0026#34;yip!\u0026#34;); } else if (weightInPounds \u0026lt; 30) { System.out.println(\u0026#34;bark.\u0026#34;); } else { System.out.println(\u0026#34;woooof!\u0026#34;); } } } public class DogLauncher { public static void main(String[] args) { Dog[] dogs = new Dog[10]; dogs[0] = new Dog(100); } } New Dog created!! Dog array를 declaration하는 시점이 아닌 Dog object를 declaration하는 시점에서 constructor가 실행됩니다.\nStatic vs. Non-static statics method는 declare된 object가 없어도 클래스 이름을 통해 호출할 수 있습니다. 반면 static method에서 사용되는 모든 변수들은 동일하게 static이어야 합니다.\n예를 들어, makeNoise method를 static으로 변경하면 오류가 발생합니다. makeNoise에서 사용하고 있는 weightInPounds이 static이 아니기 때문입니다.\n... public static void makeNoise() { if (weightInPounds \u0026lt; 10) { System.out.println(\u0026#34;yip!\u0026#34;); } else if (weightInPounds \u0026lt; 30) { System.out.println(\u0026#34;bark.\u0026#34;); } else { System.out.println(\u0026#34;woooof!\u0026#34;); } } 이렇게 까다로운 static method를 쓰는 이유는 왜일까요??\nMath라는 클래스 내의 round라는 method를 사용하고 싶은 경우, round가 static method라면 굳이 Math의 object를 declare하지 않더라도 사용할 수 있을 것 입니다.\nx = Math.round(5.6); 대신 round method 내에서 사용되는 모든 변수는 static이어야 할 것입니다.\nstatic method에서 non-static member를 사용하기 위해서는 아래와 같은 방법이 가능합니다. Dog 클래스에서 직접적으로 weightInPounds member에 접근할 수 없기 때문에, 별도의 maxDog이라는 static method를 만들고, Dog 타입의 매개변수를 받아 해당 method 안에서 weightInPounds에 접근하고 있습니다.\n... public static Dog maxDog(Dog d1, Dog d2) { if (d1.weightInPounds \u0026gt; d2.weightInPounds) { return d1; } return d2; } Static Members static member variable은 static method에서 사용될 수 있습니다. static member variable은 static method처럼 클래스 이름을 통해 접근이 가능합니다. Dog.java DogLauncher.java public class Dog { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; ... public class DogLauncher { public static void main(String[] args) { System.out.println(Dog.binomen); } } Quiz - 아래 코드는 컴파일이 될까요? (java visualizer link)\npublic class DogLoop { public static void main(String[] args) { Dog smallDog = new Dog(5); Dog mediumDog = new Dog(25); Dog hugeDog = new Dog(150); Dog[] manyDogs = new Dog[4]; manyDogs[0] = smallDog; manyDogs[1] = hugeDog; manyDogs[2] = new Dog(130); int i = 0; while (i \u0026lt; manyDogs.length) { Dog.maxDog(manyDogs[i], mediumDog).makeNoise(); i = i + 1; } } public static class Dog { ... } } Yes! manyDogs의 4번째 element가 없음에도 컴파일은 가능합니다.\n하지만, 코드를 실행할 시, Dog[3]에 도달하는 순간 null.weightInPounds에 접근하게 되며 NullPointerException 에러가 발생합니다.\n아래와 같이 아무 매개변수 없이 object를 instantiation하면 어떻게 될까요?\npublic class DogLauncher { public static void main(String[] args) { Dog my_dog = new Dog(); ... Java 에서는 위의 Dog class와 같이 constructor가 하나라도 정의되어있는 경우 default constructor가 제공되지 않습니다. public class Dog { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; public Dog() { weightInPounds = 10; } ... constructor가 하나도 정의되어 있지 않은 경우 실행되는 \u0026ldquo;일종의\u0026rdquo; default constructor는 클래스의 instantiation과 관련하여 아무런 작업을 하지 않습니다. DogLauncher.java 실행 결과 public class DogLauncher { public static class DogTest { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; } public static void main(String[] args) { DogTest my_dog = new DogTest(); System.out.println(my_dog.weightInPounds); } } 0 DogTest의 default constructor가 없지만 \u0026ldquo;일종의\u0026rdquo; 초기화가 이루어집니다. 하지만 아주 기본적인 초기화(weightInPounds를 0으로 할당하는)가 이루어집니다.\n"
},
{
	"uri": "/kr/lecture2/content1/",
	"title": "Classes and Objects, Static, Types",
	"tags": [],
	"description": "",
	"content": "이번 노트에서는 다음과 같은 내용을 다룹니다.\n자바의 메소드 (Method) 자바 프로그램이 실행되기까지 (컴파일러, JVM) Class와 object static과 non-static Methods in Java Classes 파이썬에서 두 변수의 크기를 비교하는 함수를 작성해보면 아래와 같습니다. def larger(a, b): return a \u0026gt; b print(larger(3, 2)) print(larger(1, 2)) print(larger(\u0026#34;google\u0026#34;, \u0026#34;apple\u0026#34;)) print(larger(\u0026#34;han\u0026#34;, \u0026#34;yang\u0026#34;)) # 결과 True False True False 만약 서로 자료형을 가진 두 변수를 전달하게 되면, 아래와 같은 오류가 발생합니다. 두 input 매개변수의 자료형이 다르면 크기 비교를 할 수 없기 때문입니다. Traceback (most recent call last): File \u0026#34;main.py\u0026#34;, line 11, in \u0026lt;module\u0026gt; print(larger(\u0026#34;han\u0026#34;, 3)) File \u0026#34;main.py\u0026#34;, line 2, in larger return a \u0026gt; b TypeError: \u0026#39;\u0026gt;\u0026#39; not supported between instances of \u0026#39;str\u0026#39; and \u0026#39;int\u0026#39; larger를 Java에서 구현해봅시다. LargerDemo라는 클래스를 생성하고, larger 함수를 만들어봅시다. 자바 클래스 안에 작성한 함수는 메소드라고 불립니다.\nLargerDemo.java 실행 결과 class LargerDemo { larger(a, b){ return a \u0026gt; b; } } ./LargerDemo.java:2: error: invalid method declaration; return type required larger(a, b){ ^ ./LargerDemo.java:2: error: \u0026lt;identifier\u0026gt; expected larger(a, b){ ^ ./LargerDemo.java:2: error: \u0026lt;identifier\u0026gt; expected larger(a, b){ ^ 3 errors exit status 1 파이썬의 코드를 그대로 가져와 실행한 결과, 오류가 발생합니다. 우선 올바른 구현을 확인한 뒤 어떠한 수정이 필요했는지 살펴봅시다.\nclass LargerDemo { public static boolean larger(int a, int b) { return a \u0026gt; b; } public static void main(String[] args) { larger(1, 3); } } 자바는 input 매개변수들과 return값에 대하여 타입을 명시해주어야 합니다. 자바는 파이썬과 달리 main 함수가 반드시 필요합니다. 자바의 static 메소드는 오직 static 메소드만 호출할 수 있습니다. 현재 main 함수가 static 메소드이므로 LargerDemo의 non-static 메소드는 호출할 수 없습니다.\n지금은 실행을 위해 이해 없이 static을 붙였지만, object에 대해 배워보면서 이들의 차이점을 다시 살펴봅시다.\n또다른 포인트로, 파이썬에서와 같이 int, float, String 과 같은 여러 데이터 타입에 대해 범용성을 갖고 싶다면, 같은 이름을 가진 클래스 메소드를 만들어주면 됩니다. public class LargerDemo { public static boolean larger(int a, int b) { return a \u0026gt; b; } public static boolean larger(double a, double b) { return a \u0026gt; b; } public static void main(String[] args) { System.out.println(larger(3, 2)); System.out.println(larger(3.3, 2.2)); } } 이를 메소드 오버로딩이라 부르며, 오버로딩을 위해서는 몇가지 조건이 충족되어야 합니다.\n메소드 오버로딩의 조건\n메소드의 이름이 같아야 합니다. 메소드 매개변수의 개수 또는 타입이 달라야 합니다. 참고로, 메소드 오버로딩은 return 타입과는 관계가 없습니다. 만약 return 타입만 다른 경우에는 오버로딩이 성립하지 않습니다.\nString에 대하여 large 메소드를 구현하고 싶다면, 크기 비교 시 자바에 내장된 compareTo 함수를 사용하면 됩니다.\npublic class LargerDemo { public static boolean larger(int a, int b) { return a \u0026gt; b; } /* 이렇게는 사용 불가! */ // public static boolean larger(int a, int b) { // return a - b; // } public static boolean larger(double a, double b) { return a \u0026gt; b; } public static boolean larger(String a, String b) { return a.compareTo(b) \u0026lt; 0; } public static void main(String[] args) { System.out.println(larger(3, 2)); System.out.println(larger(3.3, 2.2)); System.out.println(larger(\u0026#34;Apple\u0026#34;, \u0026#34;Yang\u0026#34;)); } } Java and Static Typing 자바에서 변수의 타입은 정해지면 바꿀 수 없습니다. - Static Typing 파이썬의 경우, 타입을 프로그램 실행 중 바꿀 수 있었기 때문에, larger 함수가 문자열에도 적용되었던 것입니다. static typing의 장단점을 살펴봅시다.\n장점\n컴파일 타임에 에러를 체크 가능 (런타임 타임 에러를 해결하는 것은 몹시 힘듭니다. 😂 ) 메소드의 호출 시 정해진 타입만 넣게 되므로 에러를 줄일 수 있습니다. input/output이 어떤 데이터 타입인지 명확하기 때문에 코드를 읽기 쉽습니다. 코드 실행의 효율성이 증가합니다. 단점\n코드가 길어지고 난잡해집니다. (앞서 large 메소드만 보더라도 3개 타입에 대해서 오버로딩을 모두 구현해야 했습니다.) Java Compilation Java 프로그램이 컴파일되고 실행되기까지의 과정을 살펴봅시다.\n.java로 끝나는 자바 코드를 작성하였다면, 자바 컴파일러인 javac를 사용하여 이를 .class 파일로 변환, 컴파일합니다. 예를 들어, LargerDemo.java라는 파일을 컴파일했다면, LargerDemo.class라는 컴파일 결과를 얻게 됩니다. 이 과정을 콘솔 터미널 상에서 나타내면 아래와 같습니다.\n~/LargerDemo$ javac LargerDemo.java ~/LargerDemo$ ls LargerDemo.class LargerDemo.java Main.class replit.nix ~/LargerDemo$ java LargerDemo.class \u0026gt; 실행 결과 javac의 컴파일 결과로 얻게 된 .class 파일은 bytecode라고 불립니다. 이 bytecode는 기존 C/C++에서의 컴파일과는 차이점을 갖습니다. 자바 코드는 JVM이라는 자바 실행을 위한 가상 컴퓨터에서 실행되기 때문에, .class 파일만 있다면 윈도우, 리눅스, MacOS와 무관하게, 그리고 intel, arm과 같은 아키텍처와 무관하게 코드를 실행할 수 있습니다. 이렇게 코드를 한차례 컴파일 한 뒤 실행하는 것의 장점이 무엇일까요?\n.class은 이미 컴파일러가 타입 체크 등 자신이 할 수 있는 검사를 미리 해두었기 때문에 실행이 보다 안전해집니다. 기계어에 좀 더 가깝기 때문에 일반 코드보다 실행이 빠릅니다. 항상 그렇지는 않지만 타인이 내가 작성한 코드를 볼 수 없게 할 수 있습니다. Defining and Instantiating Classes \u0026ldquo;구글 맵\u0026quot;상에 식당을 나타내는 클래스를 구현하고 싶습니다.\nGoogleMaps.java Restaurant.java public class GoogleMaps { public static void main(String[] args) { Restaurant m = new Restaurant(); m.name = \u0026#34;McDonald\u0026#39;s\u0026#34;; m.rating = 3.9; m.isDineInAllowed = true; Restaurant w = new Restaurant(); w.name = \u0026#34;Wangsibli\u0026#34;; w.rating = 5.0; w.isDineInAllowed = true; System.out.println(m.name); System.out.println(w.name); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; } 식당 class를 만듦으로 새로운 식당을 추가할 때 매우 편리하게 구현이 가능해졌습니다. 그리고 이렇게 만들어진 식당 하나하나들은 object가 되며, 이것이 실제 메모리에 존재하는 값이 됩니다. 이번에는 일전 LargerDemo에서와 같이, 메소드를 추가해 봅시다.\nGoogleMaps.java Restaurant.java 실행 결과 public class GoogleMaps { public static void main(String[] args) { Restaurant m = new Restaurant(); m.name = \u0026#34;McDonald\u0026#39;s\u0026#34;; m.rating = 3.9; m.isDineInAllowed = true; Restaurant w = new Restaurant(); w.name = \u0026#34;Wangsibli\u0026#34;; w.rating = 5.0; w.isDineInAllowed = true; System.out.println(m.name); System.out.println(m.rating); m.increaseRating(0.5); System.out.println(m.name); System.out.println(m.rating); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; public void increaseRating(double inc){ rating += inc; } } McDonald\u0026#39;s 3.9 McDonald\u0026#39;s 4.4 클래스의 메소드를 static으로 선언하게 되면, object의 생성 없이도 클래스 이름을 통해서 메소드를 호출할 수 있습니다. 예시를 통해 살펴봅시다.\nGoogleMaps.java Restaurant.java 실행 결과 public class GoogleMaps { public static void main(String[] args) { Restaurant.restCall(); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; public static void restCall(){ System.out.println(\u0026#34;Hello Restaurant!\u0026#34;); } public void increaseRating(double inc){ rating += inc; } } Hello Restaurant! 만약 특정 메소드를 static으로 만들고 싶다면, 해당 메소드 내에서 사용되는 모든 변수들이 static 타입을 가져야 함에 유의합니다. 때문에, increaseRating을 static으로 바꿀 수는 없습니다. increaseRating안에서 사용되는 rating이 static 변수가 아니기 때문입니다. IntelliJ는 이러한 오류를 감지하여 사용자에게 알려줄 수 있습니다.\n"
},
{
	"uri": "/kr/lecture1/hello_world/",
	"title": "Hello World",
	"tags": [],
	"description": "",
	"content": "다양한 언어에서 Hello World를 콘솔 출력해봅시다.\nPython print(\u0026#34;Hello World\u0026#34;) C #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } Python과 C의 차이점은 무엇일까요? 많은 차이가 있지만, 큰 맥락에서 이야기해봅시다.\n파이썬은 코드를 한 줄씩 실행하는 인터프리터 언어인 반면, C는 기계어로의 변환이 필요한 컴파일 언어입니다.\n따라서 컴파일러에게 코드의 시작을 알리기 위해 main이라는 함수를 두게 됩니다.\nJava를 통해 Hello World를 출력하기 위해서는 다음과 같은 코드를 사용합니다.\npublic class Hello { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } Java 코드는 클래스 안에 존재해야 하며, 클래스의 이름은 파일 이름과 동일해야 합니다. C와 유사하게 main 함수가 필수적이며, main 함수는 항상 public이어야 합니다. 그리고 main함수의 매개변수는 String의 배열이어야 합니다. 💡 IntelliJ에서 psvm을 입력하면 main 함수를 바로 생성할 수 있습니다.\n"
},
{
	"uri": "/kr/lecture6/content2/",
	"title": "Generic Lists, AList, 2D Arrays",
	"tags": [],
	"description": "",
	"content": " Generic Lists AList 2D Arrays Generic Lists 지금까지의 SLList, DLList는 모두 item에 int 타입의 데이터만 담을 수 있었습니다. String, double 등 모든 타입에 대해서 List가 동작하도록 하기 위해, class generic을 사용해 봅시다.\nclass generic을 사용하기 위해서는 클래스의 정의 시 \u0026lt;\u0026gt; 연산자를 추가하고 generic의 지칭할 키워드를 명시합니다. 아래 예에서는 T를 키워드로 사용하고 있습니다. T는 어떤 이름으로 해도 무관합니다. 이제, 클래스 내부에서의 구현 시, generic이 적용되는 모든 부분에 실제 타입 대신 T를 써주면 됩니다. public class SLList\u0026lt;T\u0026gt; { private IntNode sentinel; private int size; public class IntNode { public T item; public IntNode next; ... } ... } ... /* 사용 예시 */ SLList\u0026lt;Integer\u0026gt; s1 = new SLList\u0026lt;\u0026gt;(5); s1.insertFront(10); SLList\u0026lt;String\u0026gt; s2 = new SLList\u0026lt;\u0026gt;(\u0026#34;hi\u0026#34;); s2.insertFront(\u0026#34;apple\u0026#34;); SLList\u0026lt;Restaurant\u0026gt; s3 = new SLList\u0026lt;\u0026gt;(); s3.insertFront(new Restaurant(“Popeyes”, 4.5)); 클래스 generic을 위한 \u0026lt;\u0026gt; 연산자 안에는 reference type만이 들어갈 수 있습니다. primitive type을 generic class로 사용하기 위해서는 아래와 같이 별도의 키워드를 사용합니다.\nint: Integer double: Double char: Character boolean: Boolean long: Long etc… AList array와 class object 사이의 공통점과 차이점을 살펴봅시다.\n두 변수 모두, 특정 memory box를 지칭하는 포인터라는 점에서 공통점을 갖지만, array는 [] 연산자를 통해 특정 index에 접근할 수 있다는 점에서 차이를 갖습니다.\nclass member는 모두 이름을 가진 반면 (Walrus.name), array의 각 element들은 각각을 지칭하는 이름이 없다는 점에서 차이점을 갖습니다.\narray의 기본 public class ArrayBasics { public static void main(String[] args) { int[] z = null; int[] x, y; x = new int[]{1, 2, 3, 4, 5}; y = x; x = new int[]{-1, 2, 5, 4, 99}; y = new int[3]; z = new int[0]; int xL = x.length; String[] s = new String[6]; s[4] = \u0026#34;ketchup\u0026#34;; s[x[3] - x[1]] = \u0026#34;muffins\u0026#34;; int[] b = {9, 10, 11}; System.arraycopy(b, 0, x, 3, 2); } } 코드 출처 : http://goo.gl/tFyMEJ array의 여러 성질들\narray 자체는 pointer에 해당합니다. (reference type이기 때문에) array는 reference type이기 때문에 array의 assignment는 pointer가 가리키는 메모리를 변경하는 것이 됩니다. array의 길이는 .length를 통해 얻을 수 있습니다. int 타입의 array를 declaration하면 모든 값은 기본적으로 0을 가지며, string 타입의 array를 declaration하면 모든 값이 기본적으로 null을 갖게 됩니다. System.arraycopy()를 통해 array간 빠른 복사가 가능합니다. (arraycopy의 사용법은 python의 slicing과 유사합니다.) System.arraycopy(b, 0, x, 3, 2); (In Python): x[3:5] = b[0:2] 2D Arrays 행렬과 유사하게 2D array를 사용할 수 있으며, 2D arrary를 declaration하는 방법은 크게 두 가지가 있습니다.\ninstantiation 시 모든 element의 값을 지정해주는 방법 각 element를 new 키워드를 통해 instantiation 하는 방법 아래 예시와 사진은 파스칼의 삼각형을 2D array로 구현하고 있습니다.\npublic class ArrayBasics2 { public static void main(String[] args) { int[][] pascalsTriangle; pascalsTriangle = new int[4][]; int[] rowZero = pascalsTriangle[0]; pascalsTriangle[0] = new int[]{1}; pascalsTriangle[1] = new int[]{1, 1}; pascalsTriangle[2] = new int[]{1, 2, 1}; pascalsTriangle[3] = new int[]{1, 3, 3, 1}; int[] rowTwo = pascalsTriangle[2]; rowTwo[1] = -5; int[][] matrix; matrix = new int[4][]; matrix = new int[4][4]; int[][] pascalAgain = new int[][]{{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}}; } } 2D array 퀴즈 - 아래 코드를 실행한 뒤 x[0][0]과 w[0][0]은 어떤 값을 가지게 될까요?\npublic class SomeClass { public static void main(String[] args) { int[][] x = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; int[][] z = new int[3][]; // 3 * N 2D array 생성 z[0] = x[0]; // z[0] = {1, 2, 3} z[0][0] = -z[0][0]; // z[0] = {-1, 2, 3} int[][] w = new int[3][3]; // 3 * 3 2D array 생성 System.arraycopy(x[0], 0, w[0], 0, 3); // w[0] = {-1, 2, 3} w[0][0] = -w[0][0]; // w[0][0] = 1 } } 정답 및 코드 출처 : https://goo.gl/CqrZ7Y w는 완전히 새로운 2D array이지만, z는 array를 reference하는 1D array라고 볼 수 있습니다.\narray와 클래스의 차이점을 조금 더 알아봅시다. array의 indexing 시 런타임 타임 변수를 사용할 수 있지만, 클래스의 member를 참조하고자 할 때는 컴파일 타임 변수를 사용해야 합니다. 예시를 통해 확인하겠습니다. Array\nCode 실행 결과 int[] x = new int[]{100, 101, 102, 103}; int indexOfInterest = askUser(); int k = x[indexOfInterest]; System.out.println(k); What index do you want? 2 102 indexOfInterest는 런타임 시 사용자에 의해 정해지는 변수이지만, array의 index에 사용해도 무관합니다.\nClass\nCode 실행 결과 String fieldOfInterest = \u0026#34;mass\u0026#34;; Planet earth = new Planet(6e24, \u0026#34;earth\u0026#34;); double mass = earth.fieldOfInterest; System.out.println(mass); ClassDemo.java:5: error: array required, but Planet found. double mass = earth[fieldOfInterest]; fieldOfInterest가 mass이므로, earth.fieldOfInterest는 earth.mass가 되니 괜찮지 않나 싶을 수 있지만, fieldOfInterest는 컴파일 타임에는 확실히 알 수 없는 변수입니다. 예를 들어 누군가 fieldOfInterest = “weight”라는 코드를 중간에 삽입한다면 오류가 발생할 수 있습니다. AList Array를 통해 list를 구현하는 AList라는 자료구조를 만들어 봅시다.\nAList를 구현하면서, 반드시 지켜야 할 몇 가지 원칙들이 있습니다.\n새로운 item이 추가될 시, items[size]에 추가됩니다. AList의 전체 item 수는 size입니다. AList 가장 마지막 item의 index는 항상 size - 1이 됩니다. public class AList { private int[] items; private int size; public AList(){ items = new int[100]; size = 0; } public void addLast(int x){ items[size] = x; size += 1; } public int getLast(){ return items[size - 1]; } public int get(int i){ return items[i]; } public int size(){ return size; } } AList의 removeLast를 구현할 시, 기존 item을 0으로 초기화하는 작업은 불필요합니다. 어차피 사용하지 않는 부분이기 때문에 어떤 수가 들어가있던 무관합니다. public int removeLast(){ int returnItem = items[size - 1]; items[size - 1] = 0; size -= 1; return returnItem; } Resizing Arrays AList에 계속해서 item이 추가되고, array의 최대 크기에 임박한 경우, 새로운 array를 만들고 기존 item을 복사해주어야 합니다. 이 과정 시, 새롭게 생성하는 array의 크기를 어떻게 지정하는지에 따라 수행 속도가 달라집니다. private void resize(int capacity){ int[] a = new int[capacity]; System.arraycopy(items, 0, a, 0, size); items = a; } public void addLast(int x){ if(size == items.length){ resize(size + 1); } items[size] = x; size += 1; } "
},
{
	"uri": "/kr/lecture5/content2/",
	"title": "PUBLIC VS PRIVATE, Nested Classes",
	"tags": [],
	"description": "",
	"content": " Public vs. Private Nested Classes 현재의 SLList는 사용자가 first member에 직접 접근이 가능하기 때문에 아래와 같이 SLList의 순서를 마음대로 조작할 수 있게 됩니다.\nSLList L = new SLList(15); L.addFirst(10); L.first.next.next = L.first.next; 이러한 위험을 막기 위해, first member는 오로지 클래스 내부에서만 사용 가능하도록 private 키워드를 추가할 수 있습니다. private 키워드인 member를 클래스 밖에서 접근하려고 하면 컴파일 에러가 발생하기 때문에 실수를 방지할 수 있습니다. 사용자 측면에서도 클래스에 대해 필요한 부분만 사용하면 되기 때문에 complexity가 줄어들게 됩니다. public class SLList { private IntNode first; ... 자동차를 표현하는 “Car”라는 클래스를 구현하고자 하는 경우를 생각해 봅시다.\n사용자와 직접 상호 작용하는 페달, 운전대, 변속기는 public 권한을 두어 사용자가 접근할 수 있도록 해야 합니다. 엔진 시스템, 자동차 내부 밸브 등 기계 요소들은 사용자에게 노출되어서는 안될 것이며, private 권한을 두어야 합니다. private 키워드를 사용한다는 것은 구현 상의 권한일 뿐이지 해커의 공격에서 안전하게 보호해준다는 뜻은 아닙니다. 😊\nNested Classes Java에서는 클래스 안에 또다른 클래스 구현을 허용하고 있습니다.\n아래와 같이 하위 클래스를 private static을 구현하게 되면, SLList 외부에서는 IntNode에 접근 불가하며, IntNode에서도 SLList의 member에 접근할 수 없게 됩니다.\n(static 클래스는 오로지 static member만 사용할 수 있습니다.)\npublic class SLList { private static class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; } ... Java의 access control을 정리해보면 아래 사진과 같습니다.\n가장 관대한 public과 가장 엄격한 private 사이에 protected와 package private 키워드가 존재합니다. 아무런 access control keyword가 없다면, 기본적으로 package private이 주어집니다. 출처 : https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html 어떤 access control을 지정해야 할지 모르겠다면, 가장 엄격한 private을 최우선으로 사용하고, 필요에 따라 한 단계씩 느슨한 access control을 지정하면 됩니다.\n앞으로는 무조건 public을 사용하기보다. private을 더 우선으로 사용합시다.\nSLList 업그레이드 size method 수정 SLList의 size() method는 사용자가 사용해야 하기 때문에 public 권한을 가져야 하지만, 동시에 size() method안에서 사용되는 로직은 굳이 노출될 필요가 없습니다. 이러한 경우, private method와 public method를 분리하여 구현할 수 있습니다. public class SLList { ... private int size(IntNode p) { if (p.next == null) { return 1; } return 1 + size(p.next); } public int size() { return size(first); } } "
},
{
	"uri": "/kr/lecture4/content2/",
	"title": "Unit Test &amp; Integration Test, Simpler JUnit Tests, Primtive Types",
	"tags": [],
	"description": "",
	"content": " Unit Test \u0026amp; Integration Test Simpler JUnit Tests Primtive Types Unit Test \u0026amp; Integration Test 방대한 코드는 수많은 하위 기능들의 조합으로 구성되며, 이러한 작은 하위 기능의 단위를 Unit이라고 칭할 때, 이 Unit들을 Testing하는 작업을 Unit Test라고 합니다.\nJUnit은 이런 Unit Test를 편리하게 작업할 수 있도록 해주는 Java의 툴입니다.\nTest-Driven Development (TDD)\n일전 예시와 같이 구현하고자 하는 기능의 Test code를 먼저 작성하고, 그 test code에 맞추어 코드를 개발하는 과정을 TDD라고 합니다. 구현한 코드가 모든 Test를 통과하게 된다면 Refactoring을 수행하며, 다시 새로운 기능의 Test Code를 작성함으로 과정을 반복하면서, 차츰 차츰 거대한 프로젝트를 구성해나갈 수 있습니다. 출처 : https://medium.com/pplink/tdd로-프론트엔드-개발-날로-먹기-a95e428d929 Integration Test Unit Test를 모두 통과했다 하더라도, 코드 전체의 동작이 제대로 수행되는 것은 별개의 테스트가 필요합니다. 이렇게 좀 더 큰 범위의 코드들을 테스트하고 개선하는 것을 Integration test라고 합니다.\n테스트 시스템을 탄탄하게 다져두면, 이후의 개발 시 높은 효율을 얻을 수 있습니다.\n출처 : https://www.exasol.com/resource/integration-testing-why-you-need-it-and-how-to-make-it-painless/ Primtive Types Java에는 8가지의 primitive type이 존재하며, 이를 제외한 모든 type들은 모두 reference type이 됩니다.\n출처 : https://www.geeksforgeeks.org/data-types-in-java/ 퀴즈 - 아래 예시에서, b의 변경이 a에 영향이 있을까요?\nWalrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); 코드를 통해 확인해 봅시다.\nWalrusQuiz.java 실행 결과 public class WalrusQuiz { public static class Walrus { int weight = 0; double tusk = 0.0; public Walrus(int weight, double tusk){ this.weight = weight; this.tusk = tusk; } public String toString() { return new String(\u0026#34;weight : \u0026#34; + weight + \u0026#34; / tush : \u0026#34; + tusk); } } public static void main(String[] args) { Walrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); } } weight : 5 / tush : 8.3 weight : 5 / tush : 8.3 Walrus 클래스는 reference type 이기 때문에, b의 변경이 a에게도 영향을 미치게 됩니다. 만약 weight가 클래스의 static member였다면 위 예시는 어떻게 동작했을까요?\nWalrusQuiz.java 실행 결과 public class WalrusQuiz { public static class Walrus { static int weight = 1000; double tusk = 0.0; } public static void main(String[] args) { Walrus a = new Walrus(); Walrus b = new Walrus(); System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); Walrus.weight = 10; System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); } } a.weight : 1000\tb.weight : 1000 a.weight : 10\tb.weight : 10 static member를 변경하게 되면 해당 클래스의 모든 object들의 static member 값이 변경됩니다. 만약 이러한 변경을 막고 싶다면, 클래스 내에서 final 키워드를 사용하면 됩니다. public class WalrusQuiz { public static class Walrus { static final int weight = 1000; double tusk = 0.0; } public static void main(String[] args) { Walrus a = new Walrus(); Walrus b = new Walrus(); System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); Walrus.weight = 10; // 컴파일 에러 System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); } } 앞선 Walrus 퀴즈 결과와 비교하면서, 아래 예시를 실행하면 x의 변화가 y의 값에 영향을 줄지 생각해 봅시다.\nPrimitiveQuiz.java 실행결과 public class PrimitiveQuiz { public static void main(String[] args) { int x = 5; int y; y = x; x = 2; System.out.println(\u0026#34;x is \u0026#34; + x); System.out.println(\u0026#34;y is \u0026#34; + y); } } x is 2 y is 5 이러한 차이를 갖는 이유는 int는 primitive type인 반면, Walrus는 reference type이기 때문입니다. 앞서 언급한 바와 같이 Java에는 8가지의 primitive type이 있으며, 이를 제외한 나머지 type은 모두 reference type이 됩니다. primitive type 변수를 declaration하게 되면, 해당 변수에 일정 크기의 빈 메모리 box가 할당됩니다.\n출처 : https://sp21.datastructur.es/ 변수에 값을 대입하게 되면 메모리 box에 실제 값이 들어가게 되는 것이지요. (이러한 개념을 box notation이라고 부르겠습니다.)\nbox notation에서 y = x라는 대입은 x box에 있던 모든 비트를 y 박스의 비트로 복사하겠다는 뜻이 됩니다. 반면, reference type 변수를 declaration하고 assignment하는 방식은 primitive type과 큰 차이가 있습니다. 아래 예시를 통해 reference type의 declaration과 assignment를 살펴봅시다. public class PollQuestions { public static void main(String[] args) { Walrus a = new Walrus(1000, 8.3); } public static class Walrus { public int weight; public double tuskSize; public Walrus(int w, double ts) { weight = w; tuskSize = ts; } } } reference type 변수를 declaration하면, 해당 변수에는 아무 값을 갖지 않는 pointer가 할당됩니다. declaration된 변수를 instantiation하면, 이 시점에 a는 weight와 tuskSize를 가진 object를 가리키게 (point) 됩니다. a 자체는 값을 가진 것이 아니라, a가 가리키는 곳으로 가야 실제 값이 존재하는 것이지요. reference type간의 복사는 실제 값이 복사되는 것이 아니라, 두 pointer가 같은 값을 가리키게 되는 식으로 동작합니다. 때문에, a의 member를 변경할 시 b에도 영향을 미치게 됩니다. 강의에서는 이러한 개념을 “box and pointer” notation이라고 칭하고 있습니다.\n일전, String object의 비교 시 == 연산자를 사용할 수 없었던 점을 다시 생각해봅시다.\nString a = new String(\u0026#34;Hello\u0026#34;); String b = new String(\u0026#34;Hello\u0026#34;); if(a == b) // Nope :( if(a.equals(b)) // Yes :) ... 서로 다른 reference type을 비교한다는 것은 해당 reference type 즉, pointer를 비교하는 것에 지나지 않습니다. 실제 우리가 원하는 비교는 해당 pointer가 가리키고 있는 실제 존재하는 값을 비교하고 싶은 것입니다. a는 분명 b와 같은 값을 갖고 있는데, == 연산자로는 둘이 같은지 구분할 수가 없습니다. == 연산자는 단순히 c와 a 자체 즉, pointer를 비교하고 있기 때문입니다. "
},
{
	"uri": "/kr/lecture3/content2/",
	"title": "Managing Complexity (Helper Method)",
	"tags": [],
	"description": "",
	"content": " 코드의 complexity를 관리하기 (helper method) Managing Complexity with Helper Methods 왜 자바에서는 모든 코드가 클래스안에 존재하며, static method를 사용하고 있을까요?\n코드의 complexity를 낮추고, 사용자의 실수를 방지할 수 있기 때문입니다. static method를 사용하면, 사용자, 혹은 다른 프로그래머가 가용한 option이 적어지며, 이는 오류의 option을 줄이게 됩니다. helper method 사용하는 모든 코드가 main 함수 안에 구현되어 있다고 생각해봅시다. 방대한 코드는 가독성을 떨어뜨릴 뿐더러, 실수를 유발합니다.\n이러한 문제를 해결하기 위해 우리는 helper method를 사용하여 코드를 분리하고 정리합니다.\nlargerThanFourNeighbors 예시를 통해 살펴봅시다.\n해당 element가 좌우 2개씩, 총 4개의 element들과 비교해서 가장 크다면 해당 element를 추가하여 output array를 만듭니다.\n예를 들어, [10, 20, 30, 25, 20, 40, 10]이 input으로 사용된 경우, output은 [30, 40]이 됩니다.\n30 is greater than 10, 20, 25, and 20. 40 is greater than 25, 20, and 10. 구현은 다음과 같습니다.\nlargerThanFourNeighbors public static Dog[] largerThanFourNeighbors(Dog[] dogs) { Dog[] returnDogs = new Dog[dogs.length]; int count = 0; for(int i = 0; i \u0026lt; dogs.length; i++){ boolean isBigger = true; for(int j = i - 2; j \u0026lt;= i + 2; j++){ if(j \u0026lt; 0 || j \u0026gt;= dogs.length || j == i){ continue; } if(dogs[i].weightInPounds \u0026lt;= dogs[j].weightInPounds){ isBigger = false; } } if(isBigger) { returnDogs[count] = dogs[i]; count++; } } Dog[] answerDogs = new Dog[count]; for(int i = 0; i \u0026lt; count; i++){ answerDogs[i] = returnDogs[i]; } return answerDogs; } 방대한 양의 코드가 작성되었으며, 가독성 또한 떨어졌습니다.\n이 상황에서 helper function을 통해 작성된 코드의 complexity를 줄여봅시다.\nanswerDogs을 생성하며 array를 복사하는 부분을 별도의 method로 분리해봅시다.\nhelper method를 작성할 때는 항상 method의 input과 output에 주의하여 코드를 작성합니다.\ninput : 원본 array와 복사를 원하는 element의 개수 output : 복사가 완료된 새로운 array public static Dog[] createNewDogs(Dog[] originalDogs, int count) { Dog[] answerDogs = new Dog[count]; for (int i = 0; i \u0026lt; count; i++) { answerDogs[i] = originalDogs[i]; } return answerDogs; } 추가로 주변 4개의 이웃 element들과 크기를 비교해주는 helper method도 작성해봅시다.\ninput : 원본 array와 현재 탐색하기 원하는 index output : 조건을 만족했는지의 여부를 boolean으로 return public static boolean isBiggerThanFourNeighbors(int currentIndex, Dog[] dogs) { for (int j = currentIndex - 2; j \u0026lt;= currentIndex + 2; j++) { if (j \u0026lt; 0 || j \u0026gt;= dogs.length || currentIndex == j) { continue; } if (dogs[currentIndex].weightInPounds \u0026lt;= dogs[j].weightInPounds) { return false; } } return true; } 최종 정리된 코드는 다음과 같습니다. 기존 코드보다 가독성도 높아지고 실수가 발생할 여지 또한 줄어들었습니다.\nlargerThanFourNeighbors public static boolean isBiggerThanFourNeighbors(int currentIndex, Dog[] dogs) { for (int j = currentIndex - 2; j \u0026lt;= currentIndex + 2; j++) { if (j \u0026lt; 0 || j \u0026gt;= dogs.length || currentIndex == j) { continue; } if (dogs[currentIndex].weightInPounds \u0026lt;= dogs[j].weightInPounds) { return false; } } return true; } public static Dog[] largerThanFourNeighbors(Dog[] dogs) { Dog[] returnDogs = new Dog[dogs.length]; int count = 0; for (int i = 0; i \u0026lt; dogs.length; i++) { if (isBiggerThanFourNeighbors(i, dogs)) { returnDogs[count] = dogs[i]; count = count + 1; } } return createNewDogs(returnDogs, count); } public static Dog[] createNewDogs(Dog[] originalDogs, int count) { Dog[] answerDogs = new Dog[count]; for (int i = 0; i \u0026lt; count; i++) { answerDogs[i] = originalDogs[i]; } return answerDogs; } "
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]