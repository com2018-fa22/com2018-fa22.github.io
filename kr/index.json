[
{
	"uri": "/kr/lecture1/",
	"title": "Lecture 1",
	"tags": [],
	"description": "",
	"content": "Lecture 1 Course Introduction \u0026amp; Java Basics "
},
{
	"uri": "/kr/lecture2/",
	"title": "Lecture 2",
	"tags": [],
	"description": "",
	"content": "Lecture 2 Classes and Objects, Static, Types "
},
{
	"uri": "/kr/lecture3/",
	"title": "Lecture 3",
	"tags": [],
	"description": "",
	"content": "Lecture 3 Class Defining, Instantiating, Array of Objects, Static vs Non-static Managing Complexity(Helper Method) "
},
{
	"uri": "/kr/lecture4/",
	"title": "Lecture 4",
	"tags": [],
	"description": "",
	"content": "Lecture 4 Selection Sort, A Simple JUnit test, Testing Philosophy Selection Sort, Simpler JUnit Tests "
},
{
	"uri": "/kr/lecture5/",
	"title": "Lecture 5",
	"tags": [],
	"description": "",
	"content": "Lecture 5 PARAMETER PASSING, LISTS, ARRAYS PUBLIC VS PRIVATE, Nested Classes "
},
{
	"uri": "/kr/lecture6/",
	"title": "Lecture 6",
	"tags": [],
	"description": "",
	"content": "Lecture 6 SLList Upgrade, DLLs and Arrays Generic Lists, AList, 2D Arrays "
},
{
	"uri": "/kr/lecture7/",
	"title": "Lecture 7",
	"tags": [],
	"description": "",
	"content": "Lecture 7 Memory Efficiency, Obscurantism, Inheritance, Interface Overriding vs Overloading "
},
{
	"uri": "/kr/lecture7/content1/",
	"title": "Memory Efficiency, Obscurantism, Inheritance, Interface",
	"tags": [],
	"description": "",
	"content": "AList를 통해 배우는 Inheritance와 Interface array를 통해 구현되는 AList에 대한 구현을 계속해봅시다. 현재의 AList는 새로운 item이 계속해서 추가됨에 따라 최대 List 크기를 넘어가게 되면 resize 작업이 요구됩니다. private void resize(int capacity) { int[] a = new int[capacity]; System.arraycopy(items, 0, a, 0, size); items = a; } public void addLast(int x) { if (size == items.length) { resize(size + 100); } items[size] = x; size = size + 1; } 이 작업의 수행 시\n기존 array보다 큰 크기를 갖는 새로운 array를 생성하고 기존 array의 item을 모두 새로운 array에 복사하며 기존 array의 메모리가 반환되며 모든 resize 작업이 완료됩니다. 특히 두번째, 기존 모든 item들이 복사되는 과정에서 오랜 지연이 발생합니다.\n예를 들어, 현재 AList의 size가 100일 때, 1000번의 add가 발생한다면, 약 500,000번의 추가 연산이 요구되며, 이 복잡도는 exponential하게 증가하여 성능에 지대한 영향을 미칩니다.\n출처 : sp21.datastructur.es 이를 방지하기 위해 다음과 같은 해결법을 도입할 수 있습니다.\nresize 시, 배열의 사이즈를 현재 크기의 비례하여 증가시킵니다. 이때, 비례 상수인 REFACTOR를 적절하게 설정하며 저는 2 정도를 선택하였습니다. 참고로, 파이썬의 List가 이러한 구현을 갖는다고 합니다. public void addLast(int x) { if (size == items.length) { resize(size * REFACTOR); } items[size] = x; size = size + 1; } REFACTOR의 경우, 모든 AList가 공유하도록 static으로 설정할 수 있을 것입니다.\nRemove Method Upgrade 현재, AList에 1,000,000개의 item이 있는 상황에서 999,900번의 remove가 실행된 경우 실질적으로 필요한 item은 100개인데 비해, List는 item 1,000,000개에 해당하는 메모리를 계속 붙잡고 있게 됩니다.\n메모리 효율을 위해서 removeLast, removeFirst 메소드를 다음과 같이 개선할 수 있습니다.\nR = (실제 사용중인 size) / (Array의 length)을 정의합니다. (예를 들어 int arr[100] 중 4개만 사용중이면, R=0.04가 됩니다.) 계속해서 remove가 수행되다가 R \u0026lt; 0.25가 되는 순간 array를 resize합니다. public int removeLast() { int x = getLast(); size = size - 1; double R = (double)size / items.length; if ( R \u0026lt; 0.25 \u0026amp;\u0026amp; items.length \u0026gt;= 4 ) resize( (int) (items.length * 0.25)); return x; } 메모리의 효율성과 실행 시간은 trade-off 관계를 갖습니다. 이에 대해서는 이후 강의에서 지속적으로 다루게 됩니다.\nGeneric Programming Upgrade 앞서, int, double 등 다양한 type을 사용할 수 있게 해주는 Generic Programming() 에 대해 살펴보았습니다. 관련하여, 구현 시 발생하는 또다른 문제를 해결해봅시다.\nAList의 Constructor에서는 어떤 타입의 array가 사용될지 모릅니다. 하지만 item을 담는 클래스 변수는 declaration 해주어야 합니다. 이것의 해결을 위해서, AList의 클래스 변수는 일단 Object Type으로 declaration한 뒤, 이후 원하는 타입으로 **Type conversion(Casting)**을 해줍시다. public AList(){ items = (Item[]) new Object[initialSize]; ... 단, items를 object 타입으로 declaration 할 시, 불필요한 메모리 낭비가 생길 수 있습니다. (reference가 하나라도 있을 시, Java의 Garbage Collector가 Object의 메모리를 유지하기 때문입니다.)\n⇒ remove시, 불필요한 item을 null로 변경하도록 하면, 이를 방지할 수 있습니다.\nObscurantism in Java 관련된 개념이 완전히 이해되지 않아 이후 정리될 예정입니다.\nInterface and Implementation Inheritance 구글 맵 예시를 다시 살펴보겠습니다.\n우리 주변에는 헬스장, 병원, 지하철 역 등 다양한 Place들이 있습니다. 추가로, 지하철 역을 Java로 구현해 봅시다. GoogleMaps.java Restaurant.java Station.java public class GoogleMaps { public static void main(String[] args) { Restaurant h = new Restaurant(\u0026#34;Haengwonpark\u0026#34;, 4.5, false); Restaurant m = new Restaurant(\u0026#34;McDonald\u0026#39;s\u0026#34;, 3.5, true); Station s = new Station(\u0026#34;Wangsimni\u0026#34;, 4.1, 836); System.out.println(h.name); System.out.println(h.rating); System.out.println(h.isDineInAllowed); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } public void increaseRating(double rating) { this.rating += rating; } } public class Station { public String name; public double rating; public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } public void increaseRating(double rating) { this.rating += rating; } } Restaurant class와 Station class를 살펴보면, name, rating, constructor등 많은 중복되는 코드를 갖고 있는 것을 확인할 수 있습니다. 불필요한 코드의 중복을 inheritance(상속)을 통해 해결해 봅시다.\nPlace.java Station.java Restaurant.java public class Place { public String name; public double rating; public void increaseRating(double rating) { this.rating += rating; } } public class Station extends Place { public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } } public class Restaurant extends Place { public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } } Station과 Restaurant 클래스가 한층 깔끔해졌습니다.\n개념적으로 상속을 받는 클래스는 Child Class, 상속을 하는 클래스는 Base 혹은 Parent Class라고 합니다. Place Class에 기능을 추가하게 되면, Station과 Restaurant 또한 해당 기능을 사용할 수 있게 됩니다. 장소의 상태를 나타내는 infoString 메소드를 Place에 추가하고 사용해 봅시다.\npublic class Place { public String name; public double rating; public void increaseRating(double rating) { this.rating += rating; } public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34; rating : \u0026#34; + rating; } } Place의 infoString은 name과 rating에 대한 정보만 알 수 있어 Restaurant의 isDineInAllowed나 Station의 stopID와 같은 정보가 누락됩니다.\n따라서, Child Class에서도 자기 나름의 infoString 메소드를 구현하게 되며, 이것을 메소드 오버라이딩 (Method Overriding) 이라고 부릅니다.\nRestaurant.java Station.java public class Restaurant extends Place { public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } /* Method Overriding in Here! */ public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, isDineInAllowed : \u0026#34; + isDineInAllowed; } } public class Station extends Place { public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } /* Method Overriding in Here! */ public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, stopID : \u0026#34; +stopID; } } 마지막으로, 두 Class 모두 Place를 상속 받았기 때문에, 아래와 같은 Advanced For-loop을 사용할 수 있습니다. For-loop을 순회하며 Place가 Restaurant면 isDineInAllowed를, Station이면 stopID를 추가하여 완성된 String을 반환합니다.\nGoogleMaps.java 실행 결과 public class GoogleMaps { public static void main(String[] args) { Restaurant h = new Restaurant(\u0026#34;Haengwonpark\u0026#34;, 4.5, false); Restaurant m = new Restaurant(\u0026#34;McDonald\u0026#39;s\u0026#34;, 3.5, true); Station s = new Station(\u0026#34;Wangsimni\u0026#34;, 4.1, 836); Place [] p = new Place[3]; p[0] = h; p[1] = m; p[2] = s; for(Place elem : p) System.out.println(elem.infoString()); } } Place - name : Haengwonpark, rating : 4.5, isDineInAllowed : false Place - name : McDonald\u0026#39;s, rating : 3.5, isDineInAllowed : true Place - name : Wangsimni, rating : 4.1, stopID : 836 Overriding은 method name, parameter type, return type등 “signature” 가 완전히 일치해야 하며, 메소드의 철자 하나만 달라져도 Java는 완전히 다른 Method로 인식합니다.\nmethod 상단에 @Override 키워드를 추가하면 컴파일러가 Overriding을 검사하기 때문에 이러한 실수를 방지할 수 있습니다.\nRestaurant.java Station.java public class Restaurant extends Place { public boolean isDineInAllowed; public Restaurant(String name, double rating, boolean isDineInAllowed) { this.name = name; this.rating = rating; this.isDineInAllowed = isDineInAllowed; } @Override public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, isDineInAllowed : \u0026#34; + isDineInAllowed; } } public class Station extends Place { public int stopID; public Station(String name, double rating, int stopID) { this.name = name; this.rating = rating; this.stopID = stopID; } @Override public String infoString(){ return \u0026#34;Place - name : \u0026#34; + name + \u0026#34;, rating : \u0026#34; + rating + \u0026#34;, stopID : \u0026#34; +stopID; } } Java interface Java는 여러 Class로부터의 상속 (다중 상속)을 허용하지 않습니다. 하지만 Interface라는 것을 통해 다중 상속와 유사한 구현을 허용하고 있으며, 이는 C++의 추상 클래스와 유사한 개념을 갖습니다.\nIntelliJ에서 Interface는 다음과 같이 생성합니다.\n일전 infoString 메소드를 interface로 구현하고자 Stringable이라는 interface를 구현해봅시다.\npublic interface Stringable { String infoString(); } 이제, infoString은 Stringable에게 위임하고, Restaurant, Station과 더불어 Cafe 라는 Class를 추가로 구현하고자 합니다.\npublic class Cafe implements Stringable{ public String name; public double rating; public Cafe(String name, double rating){ this.name = name; this.rating = rating; } @Override public String infoString(){ return \u0026#34;Cafe - name: \u0026#34; + this.name + \u0026#34;, rating: \u0026#34; + this.rating; } } Cafe 코드에서 볼 수 있듯이, interface로부터 상속을 받는 키워드는 implements이며, 상속받은 Class는 interface의 모든 method를 반드시 구현해야 합니다.\ninfoString에 대한 Overriding이 없으면 Cafe Class 자체가 컴파일되지 않습니다.\npublic class Cafe implements Stringable{ ... @Override public String infoString(){ return \u0026#34;Cafe - name: \u0026#34; + this.name + \u0026#34;, rating: \u0026#34; + this.rating; } } 참고로, 일전 언급되었지만 Class는 interface와 다른 Class로부터 동시에 상속을 받을 수 있습니다.\n정리하자면, Class는 여러 interface들을 상속받을 수 있지만, 부모 Class는 단 하나만 가질 수 있습니다. public class Station extends Place implements Stringable { ... public class Restaurant extends Place implements Stringable { ... 현재 Class들 사이의 관계를 정리해보자면 다음과 같습니다.\nPlace ⇒ Restaurant Place ⇒ Station Stringable ⇒ Station, Restaurant, Cafe 이러한 설계를 어떻게 효울적으로 할 것인지에 대해서 자주 사용되는 패턴을 집대성한 “디자인 패턴” 이라는 방법론이 있습니다. (현재 공부중에 있으며, 기회가 되면 포스팅도 진행하겠습니다.)\ninheritance vs interface Class를 통한 상속과, Interface는 다음과 같이 여러 차이점을 갖고 있습니다. 주요한 특징을 몇가지 살펴봅시다.\ninterface는 그 자체로는 instantiation이 불가하며, 따라서 constructor를 가질 수 없습니다. Interface의 constructor를 구현하려 하면 IntelliJ에서 아래와 같이 에러를 감지할 것입니다. interface안에는 변수를 설정할 수는 있지만 반드시 interface내부에서 instantiation이 이루어져야 합니다. 상속받은 다른 Class는 이 값을 바꿀 수 없으며, 따라서 사실상 변수보다는 상수에 가깝습니다. public interface Stringable { String infoString(); int constVar = 3; } interface로부터 상속을 받았다면 interface내의 모든 메소드를 구현해야 합니다. "
},
{
	"uri": "/kr/",
	"title": "한양대학교 융합전자공학부 OOP 정리노트",
	"tags": [],
	"description": "",
	"content": "한양대학교 융합전자공학부 OOP 정리노트 본 사이트는 2022년 \u0026ldquo;COM2018: Object-Oriented Programming\u0026rdquo; 강의 중 발생한 코드를 정리합니다.\n현재까지 정리된 강의는 다음과 같습니다.\nLecture 1. Course Introduction \u0026amp; Java Basics Lecture 2. Classes and Objects, Static, Types Lecture 3. Defining \u0026amp; Instantiating, Static vs Non-static, Managing - Complexity, Primitive Types Lecture 4. Unit Testing Lecture 5. Linked List (IntList \u0026amp; SLList), PUBLIC VS PRIVATE, Nested Classes, List \u0026amp; Array Lecture 6. Doubly Linked List, Generic Lists, AList Lecture 7. Inheritance and Interface, Overriding and Overloading Ongoing \u0026hellip; "
},
{
	"uri": "/kr/lecture7/content2/",
	"title": "Overriding vs Overloading",
	"tags": [],
	"description": "",
	"content": "inheritance와 interface를 통해 코드를 간소화할 수 있다는 것을 알게 되었습니다.\nAList와 SList의 코드를 다시 살펴보면, 대부분의 메소드가 중복되고 있음을 발견할 수 있는데요, 상속을 통해 이러한 중복을 제거할 수 있을 것입니다.\nAList SLList public class AList\u0026lt;Item\u0026gt;{ public AList() public void insert(Item x, int position) public void addFirst(Item x) public void addLast(Item i) public Item getFirst() public Item getLast() public Item get(int i) public int size() public Item removeLast() } public class SList\u0026lt;Item\u0026gt;{ public SLList() public SLList(Item x) public void insert(Item item, int position) public void addFirst(Item x) public void addLast(Item x) public Item getFirst() public Item getLast() public Item get(int i) public int size() public Item removeLast() } 하지만, 상황에 따라, 불가피하게 input parameter가 달라져야 하는 경우가 있습니다.\n아래 예시를 살펴봅시다, 완전히 같은 코드임에도 불구하고, input parameter 타입이 다르기 때문에 Overriding이 불가합니다.\nAList SLList public static String longest(AList\u0026lt;String\u0026gt; list) { int maxDex = 0; for (int i = 0; i \u0026lt; list.size(); i += 1) { String longestString = list.get(maxDex); String thisString = list.get(i); if (thisString.length() \u0026gt; longestString.length()) { maxDex = i; } } return list.get(maxDex); } public static String longest(SLList\u0026lt;String\u0026gt; list) { int maxDex = 0; for (int i = 0; i \u0026lt; list.size(); i += 1) { String longestString = list.get(maxDex); String thisString = list.get(i); if (thisString.length() \u0026gt; longestString.length()) { maxDex = i; } } return list.get(maxDex); } 이러한 경우, Method Overloading 을 사용합니다.\nOverloading은 같은 이름을 갖는 메소드를 여러개 구현한다는 면에서 오버라이딩과 유사하지만, signature의 차이를 허용한다는 점, 같은 클래스 안에서 구현 가능하다는 차이점을 갖습니다.\n간단히 말해 같은 signature를 사용하면 overriding하고 있다고 볼 수 있습니다. 단, 철자 하나라도 차이가 나면 overriding에서 overloading으로 전환되기 때문에 @Override 키워드를 Method 상단에 추가한다는 것도 확인한 바 있었습니다.\nsignature에 해당하는 요소들은 name, arguments, return type이 있었습니다.\nOverloading의 단점은 관리가 힘들다 는 것입니다. 예를 들어, longest의 로직을 바꾸고자 하는 경우, AList 타입을 input으로 받는 longest와 SLList 타입을 input으로 받는 longest 모두를 수정해야 합니다.\nHypernyms, Hyponyms, and Interface Inheritance “Dog은 Canine이다” 라는 말은 성립하지만, “Dog은 Canine이다” 라는 말은 Fox, Coyote등의 반례가 존재하기 때문에 성립할 수 없습니다.\n이러한 Class들 사이의 상속 관계를 is-a 관계라고 합니다.\nDog is-a Canine은 참이지만, Animal is-a Dog은 불가하지요.\n위 그림을 통해 살펴보면, 상위 클래스 is-a 하위 클래스라는 관계는 성립하지 않는다는 것을 알 수 있습니다.\n강의에서는 Hypernym이라는 단어로 상위 개념을, Hyponym이라는 단어로 하위 개념을 지칭하고 있습니다.\nAList와 SList의 상위 개념이 되는 ListOOP interface를 구현해봅시다. public interface ListOOP\u0026lt;Item\u0026gt; { public void addFirst(Item x); public void addLast(Item y); public Item getFirst(); public Item getLast(); public Item removeLast(); public Item get(int i); public void insert(Item x, int position); public int size(); } AList와 SList는 모두 ListOOP interface에서 implements 받으며, AList는 ListOOP 내에 있는 모든 Method를 구현해야 합니다. (Interface 상속의 특징이었지요.)\npublic class AList\u0026lt;Item\u0026gt; implements ListOOP\u0026lt;Item\u0026gt;{ ... public void addLast(Item x) { ... longest Method를 ListOOP내에서 declaration 한 결과, 이제 overloading을 하지 않아도, longest Method를 SLList, AList 모두에 사용 가능해졌습니다.\npublic static String longest(ListOOP\u0026lt;String\u0026gt; list) { int maxDex = 0; for (int i = 0; i \u0026lt; list.size(); i += 1) { String longestString = list.get(maxDex); String thisString = list.get(i); if (thisString.length() \u0026gt; longestString.length()) { maxDex = i; } } return list.get(maxDex); } Overriding의 원리 아래 예시에서, someList.addFirst를 호출하면, SLList의 addFirst 메소드가 호출될 것입니다.\n이러한 실행이 가능한 이유는 무엇일까요?\npublic static void main(String[] args) { ListOOP\u0026lt;String\u0026gt; someList = new SLList\u0026lt;String\u0026gt;(); someList.addFirst(\u0026#34;elk\u0026#34;); } \u0026ldquo;SLList is-a ListOOP\u0026rdquo; 라는 관계를 기억하시나요? 더불어, reference type은 실질적인 메모리를 갖는 것이 아닌, 해당 메모리의 주소를 가리키는 변수라고 하였습니다. 따라서, ListOOP 타입의 변수는, SLList 타입을 갖는 메모리 주소를 가질 수 있게 됩니다. 하지만, ListOOP is-not-a SLList이기 때문에 이 반대는 성립하지 않습니다. Implementation Inheritance: Default Methods 본디, interface는 Method의 declaration만을 허용하지만, default 키워드를 추가하면, Method의 구현이 가능해집니다.\npublic interface Stringable { default String infoString(){ return \u0026#34;Default String\u0026#34;; } } default Method는 하위 클래스에서 다시금 Overriding이 가능합니다. 아래 print의 경우, get을 사용하는 것은 SLList에게 매우 비효율적인 방식이기 때문에, SLList Class에서 별도로 Overriding을 구현해 주었습니다.\npublic interface ListOOP\u0026lt;Item\u0026gt; { ... default public void print() { for (int i = 0; i \u0026lt; size(); i += 1) { System.out.print(get(i) + \u0026#34; \u0026#34;); } System.out.println(); } } public interface SLList\u0026lt;Item\u0026gt; implements ListOOP { @Override public void print() { for (Node p = sentinel.next; p != null; p = p.next) { System.out.print(p.item + \u0026#34; \u0026#34;); } System.out.println(); } } Static and Dynamic Type, Dynamic Method Selection compile-time type이라고도 불리는 static type은 변수의 declaration시 설정되는 타입으로, 절대 바뀌지 않습니다. (일반적으로 변수 선언 시 지정되는 타입이 여기 해당합니다.) dynamic type은 변수의 instantiation 시(new 사용 시) 설정되는 타입으로, 해당 변수가 실질적으로 가리키는 object의 타입입니다. 예시를 통해 static type / dynamic type에 대한 이해를 해봅시다. public static void main(String[] args) { LivingThing lt1; // lt1의 static type은 LivingThing lt1 = new Fox(); // lt1의 dynamic type은 Fox Animal a1 = lt1; // a1의 static type은 Animal Fox h1 = new Fox();// h1의 static type은 Fox, dynamic type은 Fox lt1 = new Squid(); // lt1의 dynamic type은 Squid } 출처 : sp21.datastructur.es static type은 declaration 시 결정되어 바뀌지 않는 반면, lt1에서 볼 수 있듯이 dynamic type은 변경이 가능합니다.\n일전 예시에서도, someList의 static type은 ListOOP였지만, dynamic type은 SLList가 되었습니다.\npublic static void main(String[] args) { ListOOP\u0026lt;String\u0026gt; someList = new SLList\u0026lt;String\u0026gt;(); someList.addFirst(\u0026#34;elk\u0026#34;); } Method의 호출 시에는 dynamic type의 Method가 호출되며, 이를 dynamic method selection 이라고 부릅니다. Dynamic Method Selection Puzzle: Try to Predict the Results 아래 코드를 실행하면 어떤 결과를 얻게 될까요?\nAnimal.java Dog.java DogLauncher.java 실행결과 public interface Animal { default void greet(Animal a) { System.out.println(\u0026#34;hello animal\u0026#34;); } default void sniff(Animal a) { System.out.println(\u0026#34;sniff animal\u0026#34;); } default void praise(Animal a) { System.out.println(\u0026#34;u r cool animal\u0026#34;); } } public class Dog implements Animal { @Override public void sniff(Animal a) { System.out.println(\u0026#34;dog sniff animal\u0026#34;); } public void praise(Dog a) { System.out.println(\u0026#34;u r cool dog\u0026#34;); } } public class DogLauncher { public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); a.sniff(d); d.praise(d); a.praise(d); } } hello animal dog sniff animal u r cool dog u r cool animal 왜 이런 결과를 얻었을까요?\nDynamic Method Selection의 두가지 규칙을 생각하면서 코드를 해석해봅시다.\nRule 1 : 호출되는 Method의 Signature는 오로지 Complie Time에 결정되며, 따라서 Static Type을 사용하게 된다. Dog launcher의 코드를 통해 Rule 1을 적용해봅시다. (코드의 주석으로 Signature를 적어두었습니다.) public class DogLauncher { public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); // greet(Animal a) a.sniff(d); // sniff(Animal a) d.praise(d); // praise(Dog a) a.praise(d); // praise(Animal a) } } a의 static type은 Animal이므로, 오로지 Animal 클래스 내의 Method만 사용됩니다.\nRule 2 : dynamic type을 갖는 object의 Method 호출 시, Complie Time에 결정된 signature와 정확히 일치하는 Method가 호출된다. Dog launcher의 코드를 통해 Rule 2를 적용해봅시다. public class DogLauncher { public static void main(String[] args) { Animal a = new Dog(); Dog d = new Dog(); a.greet(d); // greet(Animal a) =\u0026gt; Dog의 greet(Animal a) 호출 a.sniff(d); // sniff(Animal a) =\u0026gt; Dog의 sniff(Animal a) 호출 d.praise(d); // praise(Dog a) =\u0026gt; Dog의 praise(Dog a) 호출 a.praise(d); // praise(Animal a) =\u0026gt; Dog의 praise(Animal a) 호출 } } 아마 혼란스러운 부분은 제일 마지막 코드가 아닐까 싶습니다.\n이때의 praise는 Dog.praise()가 아닌, Animal.praise()가 호출됩니다. a의 dynamic type이 Dog일지라도, praise(Animal a)는 Dog클래스 내부에 존재하지 않습니다. 따라서 Dog is-a Animal에 따라 Animal.praise()가 호출됩니다. 결국, a의 static type이 Animal이며, praise(Animal a)가 Dog 내부에 Override되어있지 않아 발생하는 결과입니다. 만약 praise(Animal a)를 Override 한다면, 의도한 결과를 얻게 됩니다.\nAnimal.java Dog.java 실행결과 public interface Animal { default void greet(Animal a) { System.out.println(\u0026#34;hello animal\u0026#34;); } default void sniff(Animal a) { System.out.println(\u0026#34;sniff animal\u0026#34;); } default void praise(Animal a) { System.out.println(\u0026#34;u r cool animal\u0026#34;); } } public class Dog implements Animal { @Override public void sniff(Animal a) { System.out.println(\u0026#34;dog sniff animal\u0026#34;); } @Override public void praise(Animal a) { System.out.println(\u0026#34;u r cool dog\u0026#34;); } } hello animal dog sniff animal u r cool dog u r cool dog "
},
{
	"uri": "/kr/lecture6/content1/",
	"title": "SLList Upgrade, DLLs and Arrays",
	"tags": [],
	"description": "",
	"content": " SLList Upgrade DLLs and Arrays 앞선 SLList의 단점들을 하나씩 개선해 봅시다.\nsize() 개선 기존 IntNode에서는 전체 List의 크기를 알아내기 위해 모든 List를 순회해야 했습니다. 이와 달리, SLList에서는 전체 List의 길이를 보관하는 별도의 member variable을 만듭니다. 이는 SLList의 초기 생성 시에는 1이 될 것이며, Node를 추가할 때마다 1씩 증가하게 됩니다. public class SLList { private IntNode first; private int size; public SLList() { first = null; size = 0; } public void addFirst(int x) { ... size = size + 1; } ... addLast 개선 현 addLast의 문제는 비어있는 SLList에 addLast를 수행할 시, p.next가 null.next가 되어 오류가 발생한다는 것입니다. public class SLList { private IntNode first; private int size; public SLList() { first = null; size = 0; } public void addLast(int x) { size += 1; IntNode p = first; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } ... 이러한 오류를 방지하기 위해 if를 추가할 수 있지만, 첫 시작에 대한 조건을 추가하기 시작하면, 다른 method에서도 계속해서 추가 조건이 붙는 상황이 발생하게 됩니다. public void addLast(int x) { size += 1; if (first == null) { first = new IntNode(x, null); return; } IntNode p = first; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } 본질적인 해결을 위해서 sentinal node라는 개념을 통해 예외를 제거하고, 모든 상황을 동일하게 만들 수 있습니다.\n수정되는 코드를 먼저 살펴보겠습니다. private IntNode sentinel; private int size; public SLList() { sentinel = new IntNode(63, null); size = 0; } public SLList(int x) { sentinel = new IntNode(63, null); sentinel.next = new IntNode(x, null); size = 1; } public void addFirst(int x) { sentinel.next = new IntNode(x, sentinel.next); size = size + 1; } public void addLast(int x) { size = size + 1; IntNode p = sentinel; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } ... List의 크기와 상관없이 (아무 item이 없더라도), sentinal이 항상 존재하며, sentinal 또한 하나의 Node이기에 item을 갖게 됩니다. 하지만 sentinal의 item은 사용되지 않으므로 어떠한 값을 가지던 상관없습니다. 출처 : https://sp21.datastructur.es/ Part 2: DLLs and Arrays SLList의 또 다른 문제점은, addFirst와 addLast에 걸리는 시간이 큰 차이를 갖는다는 점입니다. addLast의 경우, while문을 통해 전체 list의 마지막으로 접근해야 비로소 add가 가능한 반면, addFirst는 first를 통해 바로 추가가 가능합니다. public void addFirst(int x) { sentinel.next = new IntNode(x, sentinel.next); } ... public void addLast(int x) { size += 1; IntNode p = sentinel; while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } 이를 해결하기 위해서, 전체 list의 마지막을 가리키는 last라는 새로운 IntNode 타입의 member를 추가해봅시다. last를 별도 저장하고 있기 때문에, addLast의 실행 시간을 단축시킬 수 있으며, addLast 될 때마다 이를 갱신합니다. private IntNode sentinel; private IntNode last; private int size; ... public SLList() { sentinel = new IntNode(63, null); last = sentinel; size = 0; } public SLList(int x) { sentinel = new IntNode(63, null); sentinel.next = new IntNode(x, null); last = sentinel.next; size = 1 } public void addLast(int x) { size = size + 1; IntNode p = last; p.next = new IntNode(x, null); last = p.next; } ... last member를 추가하여 addLast()가 무척 빨라졌습니다.\n하지만, removeLast가 여전히 느린 상황입니다. 마지막 Node를 지우게 되면, 그 이전 Node를 새롭게 last로 갱신해야 하는데, 현재의 SLList는 한 방향으로만 서로를 연결하고 있어 last ⇒ first 방향으로의 순서는 곧바로 알 수 없습니다. 출처 : https://sp21.datastructur.es/ 새로운 구조의 Linked List를 통해 이 문제를 해결해봅시다.\nDoubly Linked List (DLL) Node간 next와 prev 관계를 모두 저장하는 doubly linked list를 구현해 봅시다. doubly linked list를 구현하는 두가지 방식이 있습니다. 1. sentinal node는 item과 무관하게 List의 첫 시작을 가리키는 node였습니다. back sentinal을 두게 하여 마지막 Node의 위치도 기억하도록 할 수 있습니다.\n2. front / back sentinal을 두는 것은 코드 구현을 복잡하게 만들고, 사용되지 않는 불필요한 부분이 생기도록 만듭니다. 이를 해결하기 위한 방법으로, sentinal의 next는 첫번째 Node를, sentinal의 prev는 마지막 Node를 바라보게 하는 circular sentinal을 구현할 수 있습니다.\n출처 : https://sp21.datastructur.es/ 구현 코드는 과제와 관련되어 있으므로, 추후 추가 예정입니다.\n"
},
{
	"uri": "/kr/lecture5/content1/",
	"title": "PARAMETER PASSING, LISTS, ARRAYS",
	"tags": [],
	"description": "",
	"content": " PARAMETER PASSING Instantiation of Arrays Linked List in Java 지난 시간, primitive type과 reference type에 대해서 배워보았습니다.\n이번에는 이들이 method의 매개변수로 전달되는 과정을 살펴봅시다.\n퀴즈 - 아래 코드에서, walrus와 x중 어떠한 값이 변경되고 유지될까요?\nPollQuestions.java 실행결과 public class PollQuestions { public static void main(String[] args) { Walrus walrus = new Walrus(3500, 10.5); int x = 9; doStuff(walrus, x); System.out.println(walrus); System.out.println(x); } public static void doStuff(Walrus W, int x) { W.weight = W.weight - 100; x = x - 5; } ... weight: 3400, tusk size: 10.50 9 primitive type은 method의 매개변수로 전달되면서 새로운 변수가 생성되고 복사되는 과정이 진행됩니다. 반면, reference type은 method의 매개변수로 전달되어도 해당 변수가 가리키고 있던 실제 값은 변하지 않기 때문에 doStuff안에서의 작업에 영향을 받습니다. 이 과정을 시각화해보면 다음과 같습니다.\nInstantiation of Arrays array는 reference type이기 때문에 array를 declaration한다는 것은 그저 pointer를 만들어준다는 뜻이 됩니다. array를 instantiation하고 assignment해야 비로소 의미 있는 값을 가리키는 array가 됩니다. int[] my_arr; // Nothing :( int[] a = new int[]{0, 1, 2, 95, 3}; a = new int[]{2, 3, 4, 5}; 위 코드에서, a 자체는 pointer이기 때문에 a가 가리키고 있는 값은 얼마든지 바꿀 수 있습니다. 마지막 라인과 같이 값의 변경이 일어난 경우, 기존 a가 가리키던 값은 더이상 사용되지 않는 메모리가 되며, Java는 이러한 불필요한 메모리를 똑똑하게 관리해주는 garbage collector를 갖고 있습니다. IntList and Linked Data Structures Array vs. List array와 list는 모두 동일한 type의 item들을 저장한다는 공통점이 있지만, 아래와 같은 차이점들을 갖습니다.\narray는 크기가 고정되어 있으며, initialization시 크기를 지정해주어야 합니다. (linked) list는 크기가 고정되어 있지 않아 initialization시 크기를 지정해줄 필요가 없습니다. 코드 구현을 시작하면서, Int 타입을 담는 Linked List, IntList를 구현해봅시다.\nIntList는 연쇄적으로 얽혀 있는 사슬 구조를 가지며, 한 방향으로 계속 길어집니다. 때문에, item을 담는 first와, 다음 IntList 가리키는 rest를 member로 갖습니다. public class IntList { public int first; public IntList rest; public IntList(int f, IntList r) { first = f; rest = r; } ... IntList의 크기를 알아내기 위해서는 rest가 더이상 존재하지 않는 끝지점까지 IntList를 순회하면서 그 개수를 counting 해야 합니다.\n이를 구현하는 방식으로 1. 재귀함수 / 2. while문을 사용하는 두가지 접근을 취해봅시다.\n재귀함수 구현 while문 구현 public int size() { if(rest == null){ return 1; } return 1 + rest.size(); } public int iterativeSize() { IntList l = this; int count = 1; while(l.rest != null){ l = l.rest; count++; } return count; } 다음으로, 특정 index의 값을 반환하는 get 함수를 구현해봅시다.\n주어진 index만큼 IntList를 순회하고 원하는 위치에서의 값을 반환합니다. get 또한 1. 재귀함수 / 2. while을 통한 구현이 가능합니다. 재귀함수 구현 while문 구현 public int get(int i) { if (i == 0) { return first; } return rest.get(i - 1); } public int get(int i) { IntList l = this; while(i \u0026gt; 0){ l = l.rest; i--; } return l.first; } 지금까지 구현된 method를 실행하는 main 함수를 작성해봅시다.\nIntList.java 실행결과 public static void main(String[] args) { IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); System.out.println(L.iterativeSize()); System.out.println(L.size()); System.out.println(L.get(1)); } 3 3 10 IntList 개선하기 기존의 liIntList는 새로운 node를 추가하고자 할 시, .rest를 반복해서 붙여줘야 했습니다. 이에 따라 사용자가 마음대로 IntList의 순서를 바꿀 수 있게 되는 위험성을 내포하게 됩니다.\nIntList my_list = new IntList(1, null); my_list.rest = new IntList(2, null); my_list.rest.rest = new IntList(3, null); IntList의 단점을 극복하는 SLList를 구현해봅시다.\nSLLists는 Node와 Linked List를 클래스 단위에서 구분합니다. 가장 앞에 등장하는 IntNode를 first로 지정하고, 새로운 Node가 추가될 때마다 first를 갱신합니다. 따라서 가장 먼저 추가한 Node는 Linked List 상에서 가장 마지막에 위치하게 됩니다. public class SLList { private static class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; } } public IntNode first; public SLList(int x){ first = new IntNode(x, null); } ... SLList와 IntList를 비교해봅시다.\nSLList는 초기에만 new 키워드가 사용되었습니다. 이는 곧 새로운 object의 생성은 SLList에서 알아서 처리해준다는 뜻이 됩니다. 이를 통해 사용자의 실수가 줄어들 것이며, 사용자는 Linked List의 생성자에 대한 정보는 일절 몰라도 됩니다. 단지 addFirst()만 사용할 줄 알면 됩니다. SLList IntList SLList L = new SLList(15); L.addFirst(10); L.addFirst(5); int x = L.getFirst(); IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); int x = L.first; "
},
{
	"uri": "/kr/lecture4/content1/",
	"title": "Selection Sort, A Simple JUnit test, Testing Philosophy",
	"tags": [],
	"description": "",
	"content": " Selection Sort A Simple JUnit test Testing Philosophy 내가 작성하는 모든 코드가 완벽하리라 보장할 수는 없을 것입니다. 이를 위해 다양한 test 코드를 만들고 이를 통해 잘못된 로직을 수정하는 방식을 사용하여 코드의 안정성을 높일 수 있습니다.\nSelection Sort 구현 String array가 주어졌을 때, 알파벳 순으로 정렬된 array를 반환하는 sort 코드를 작성해봅시다.\n예를 들어, {”i”, “am”, ”a”, “student”}라는 array는 {”a”, “am”, “i”, “student”}가 될 것입니다. sort method를 구현하기 전, 테스트 코드를 작성해봅시다. 잘못된 결과가 발견될 경우, println을 통해 콘솔 출력을 해줍니다. public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); for (int i = 0; i \u0026lt; input.length; i++){ if(!input[i].equals(expected[i])){ System.out.println(\u0026#34;Error in index\u0026#34; + i + \u0026#34; expected : \u0026#34; + expected[i] + \u0026#34;/ actual : \u0026#34; + input[i]); } } } ... public static void main(String[] args) { testSort(); } String의 비교는 == 연산자가 아닌, .equals() method를 사용합니다.\n이렇게 모든 element를 비교하거나, 콘솔 출력을 하는 코드를 작성하는 것은 매우 비효율적이고 반복적입니다.\n따라서, 우리는 JUnit이라는 유용한 툴을 사용하고자 합니다.\n프로그램의 최상단에 junit 패키지를 import한 뒤, 원하는 method를 사용하면 됩니다. 이번 예시에 적합한, 두 array가 동일한지 비교해주는 assertArrayEquals라는 method를 사용하겠습니다. import static org.junit.Assert.*; public class TestSort { public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); assertArrayEquals(expected, input); } ... Sort의 Test 코드를 작성하였으므로, 이제 본격적인 sort 알고리즘을 구현해봅시다. 구현할 sort 알고리즘은 selection sort 알고리즘입니다.\n전체 array에서 가장 작은 item을 찾아 첫번째 위치로 변경합니다. array의 첫번째 item은 이미 가장 작은 item이니, 이를 제외한 두번째 item부터 다시 가장 작은 item을 찾습니다. 위 작업을 모든 array가 sorting 완료될 때까지 반복합니다. 출처 : https://www.hackerearth.com selection sort를 잘 살펴보면, 특정 array 내에서 가장 작은 item을 찾아내는 과정이 반복됩니다.\n이를 helper method로 분리할 수 있고, 이렇게 분리된 method를 위해서 다시 test code를 작성할 수 있습니다.\n출처 : sp21.datastructur.es 가장 작은 item을 찾는 findSmallest method와 이를 위한 test code를 작성해봅시다.\nTestSort.java Sort.java public void testFindSmallest() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; assertEquals(1, Sort.findSmallest(input, 0)); String[] input2 = {\u0026#34;pizza\u0026#34;, \u0026#34;hamburger\u0026#34;, \u0026#34;pork\u0026#34;, \u0026#34;sushi\u0026#34;, \u0026#34;chicken\u0026#34;, \u0026#34;pasta\u0026#34;}; assertEquals(4, Sort.findSmallest(input2, 0)); } public static int findSmallest(String[] x, int startIndex) { int smallestIndex = startIndex; for (int i = startIndex + 1; i \u0026lt; x.length; i += 1) { if (x[i].compareTo(x[smallestIndex]) \u0026lt; 0) { smallestIndex = i; } } return smallestIndex; } 문자열의 비교를 위해 compareTo()를 사용해야 합니다.\ncompareTo() 이 method는 두 문자열을 비교하여 상황에 따라 양수, 0, 음수를 반환합니다. 해당 String이 매개변수로 주어진 String보다 작다면, 음수를 반환하여, 이에 따라 가장 작은 item의 index를 업데이트합니다. 다음으로, array의 두 item의 위치를 바꿔주는 swap 함수와 test 코드를 구현합시다.\nTestSort.java Sort.java public void testSwap() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; Sort.swap(input, 1, 2); String[] expected = {\u0026#34;banana\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; assertArrayEquals(expected, input); } public static void swap(String[] x, int a, int b) { String c = x[a]; x[a] = x[b]; x[b] = c; } 마지막으로, 최종 sort method와 test 코드를 작성합니다.\nTestSort.java Sort.java public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); assertArrayEquals(expected, input); } public static void sort(String[] x) { sort(x, 0); } private static void sort(String[] x, int startIndex) { if (startIndex \u0026gt;= x.length - 1) { return; } int smallestIndex = findSmallest(x, startIndex); swap(x, startIndex, smallestIndex); sort(x, startIndex + 1); } sort 알고리즘은 반복적 실행이 필요하기 때문에 재귀 함수를 사용하는 helper method를 구현하였습니다. 더불어, helper method와 원본 함수가 동일한 이름을 갖고 있으며, 이는 method overloading이 사용되었음을 알 수 있습니다. 이렇게 test 코드를 잘 작성해두면 여러 이점이 있습니다.\n협업 시 다른 프로그래머가 코드를 작업하더라도, test를 잘 통과하는지만 살펴보면 되기 때문에 효율적이게 됩니다. 코드를 나누어 test하기 때문에 전체 실행 시간이 적어지고, 코드 작성의 뼈대를 구축할 수 있게 됩니다. 더불어, 코드를 모두 작성한 뒤, 기능에 영향을 미치지 않는 선에서 불필요한 변수의 선언, 코드의 중복을 제거하는 것을 refactoring이라고 합니다. 추가로, org.junit.Test를 import 하고 @Test를 test code 위에 붙여주면, main 함수 없이도 특정 test code를 실행할 수 있게 됩니다.\nimport org.junit.Test; import static org.junit.Assert.*; public class TestSort { @Test public void testSort() { String[] input = {\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;coconut\u0026#34;}; String[] expected = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;coconut\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pineapple\u0026#34;}; Sort.sort(input); assertArrayEquals(expected, input); } } "
},
{
	"uri": "/kr/lecture3/content1/",
	"title": "Class Defining, Instantiating, Array of Objects, Static vs Non-static",
	"tags": [],
	"description": "",
	"content": " Java 클래스의 Defining과 Instantiating Arrays of Objects static vs non-static object instantiation 클래스에는 다양한 instance method, variable들이 존재합니다. 따라서, object의 생성 시, 이 member들을 초기화해주는 작업이 필요하며, 이를 object instantiation이라고 부릅니다.\nobject instantiation을 하는 여러 방법이 있지만, 클래스 내부에서 constructor를 만들어줌으로 이를 수행할 수 있습니다.\npublic class Dog { public int weightInPounds; /** One integer constructor for dogs. */ public Dog(int w) { weightInPounds = w; } public void makeNoise() { if (weightInPounds \u0026lt; 10) { System.out.println(\u0026#34;yip!\u0026#34;); } else if (weightInPounds \u0026lt; 30) { System.out.println(\u0026#34;bark.\u0026#34;); } else { System.out.println(\u0026#34;woooof!\u0026#34;); } } } constructor의 특징\n리턴 타입이 없고, 클래스와 같은 이름을 갖는 method입니다. object가 new 키워드를 통해 생성될 때 실행됩니다. 그 밖의 함수들은 static, 혹은 non-static method가 됩니다. 일전 살펴본 Dog 클래스를 main에서 사용해봅시다. 코드 주석으로 declaration, instantiation, assignment에 대한 설명이 추가되어 있습니다.\npublic class DogLauncher { public static void main(String[] args) { Dog smallDog; // declaration: 메모리에 Dog 변수를 할당 new Dog(20); // Dog 클래스를 Dog object로 instantiation smallDog = new Dog(5); // assignment : instantiation된 object를 변수에게 할당 Dog hugeDog = new Dog(150); smallDog.makeNoise(); hugeDog.makeNoise(); } } 위 코드 new Dog(20);의 경우, instantiation는 되지만 해당 assignment가 되지 않아, 이 dog은 실제로는 사용할 수 없으므로 사라지게 됩니다. 더불어, Dog hugeDog = new Dog(150);의 경우, declaration instantiation assignment가 한 줄에서 모두 실행되는 형태를 갖습니다. 그렇다면, declaration과 assignment를 동시에 실행하는 것과 분리하는 것의 차이는 무엇일까요?\n배가 고프다면 맛있는 식당으로, 그렇지 않다면 평범한 식당으로 가는 로직을 구현해 봅시다.\npublic class GoogleMaps { public static void main(String[] args) { Restaurant m = new Restaurant(\u0026#34;McDonald\u0026#39;s\u0026#34;); m.rating = 3.9; m.isDineInAllowed = true; Restaurant w = new Restaurant(\u0026#34;Wangsibli\u0026#34;); w.rating = 5.0; w.isDineInAllowed = true; boolean hungry = false; if(hungry) { Restaurant r = new Restaurant(\u0026#34;HangWonPark\u0026#34;); } else { Restaurant r = new Restaurant(\u0026#34;ShinSoJae\u0026#34;); } System.out.println(r.name); } } 위 코드에서 r은 if{ }문 안에서 생성되었으므로, 괄호를 벗어나게 되면 사라지게 됩니다. 때문에, System.out.println(r.name);는 실행될 수 없습니다. (이를 변수의 스코프 라고 부릅니다.)\ndeclaration과 assignment를 분리하면 우리가 원하던 기능을 구현할 수 있고, 유연한 프로그래밍이 가능해집니다. 더불어, declaration과 instantiation을 한 라인에 작성하므로 코드의 양을 줄일 수 있고, 실수도 줄일 수 있습니다. ... boolean hungry = false; Restaurant r; if(hungry) { r = new Restaurant(\u0026#34;HangWonPark\u0026#34;); } else { r = new Restaurant(\u0026#34;ShinSoJae\u0026#34;); } System.out.println(r.name); } } Arrays of Objects 자바에서는 array 또한 object입니다. 따라서 array도 instantiation을 필요로 합니다.\nDog[] dogs = new Dog[2]; dogs[0] = new Dog(8); dogs[1] = new Dog(20); dogs[0].makeNoise(); 위 예시에서는 object의 array를 생성하고 있으므로, array의 각 object들 또한 instantiation을 필요로 합니다.\n만약 Dog의 Constructor에 console output을 추가한 뒤 Dog array를 declaration하면 어떤 결과를 얻을까요?\nDog.java DogLauncher.java 실행 결과 public class Dog { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; /** One integer constructor for dogs. */ public Dog(int w) { weightInPounds = w; System.out.println(\u0026#34;New Dog created!!\u0026#34;); } public void makeNoise() { if (weightInPounds \u0026lt; 10) { System.out.println(\u0026#34;yip!\u0026#34;); } else if (weightInPounds \u0026lt; 30) { System.out.println(\u0026#34;bark.\u0026#34;); } else { System.out.println(\u0026#34;woooof!\u0026#34;); } } } public class DogLauncher { public static void main(String[] args) { Dog[] dogs = new Dog[10]; dogs[0] = new Dog(100); } } New Dog created!! Dog array를 declaration하는 시점이 아닌 Dog object를 declaration하는 시점에서 constructor가 실행됩니다.\nStatic vs. Non-static statics method는 declare된 object가 없어도 클래스 이름을 통해 호출할 수 있습니다. 반면 static method에서 사용되는 모든 변수들은 동일하게 static이어야 합니다.\n예를 들어, makeNoise method를 static으로 변경하면 오류가 발생합니다. makeNoise에서 사용하고 있는 weightInPounds이 static이 아니기 때문입니다.\n... public static void makeNoise() { if (weightInPounds \u0026lt; 10) { System.out.println(\u0026#34;yip!\u0026#34;); } else if (weightInPounds \u0026lt; 30) { System.out.println(\u0026#34;bark.\u0026#34;); } else { System.out.println(\u0026#34;woooof!\u0026#34;); } } 이렇게 까다로운 static method를 쓰는 이유는 왜일까요??\nMath라는 클래스 내의 round라는 method를 사용하고 싶은 경우, round가 static method라면 굳이 Math의 object를 declare하지 않더라도 사용할 수 있을 것 입니다.\nx = Math.round(5.6); 대신 round method 내에서 사용되는 모든 변수는 static이어야 할 것입니다.\nstatic method에서 non-static member를 사용하기 위해서는 아래와 같은 방법이 가능합니다. Dog 클래스에서 직접적으로 weightInPounds member에 접근할 수 없기 때문에, 별도의 maxDog이라는 static method를 만들고, Dog 타입의 매개변수를 받아 해당 method 안에서 weightInPounds에 접근하고 있습니다.\n... public static Dog maxDog(Dog d1, Dog d2) { if (d1.weightInPounds \u0026gt; d2.weightInPounds) { return d1; } return d2; } Static Members static member variable은 static method에서 사용될 수 있습니다. static member variable은 static method처럼 클래스 이름을 통해 접근이 가능합니다. Dog.java DogLauncher.java public class Dog { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; ... public class DogLauncher { public static void main(String[] args) { System.out.println(Dog.binomen); } } Quiz - 아래 코드는 컴파일이 될까요? (java visualizer link)\npublic class DogLoop { public static void main(String[] args) { Dog smallDog = new Dog(5); Dog mediumDog = new Dog(25); Dog hugeDog = new Dog(150); Dog[] manyDogs = new Dog[4]; manyDogs[0] = smallDog; manyDogs[1] = hugeDog; manyDogs[2] = new Dog(130); int i = 0; while (i \u0026lt; manyDogs.length) { Dog.maxDog(manyDogs[i], mediumDog).makeNoise(); i = i + 1; } } public static class Dog { ... } } Yes! manyDogs의 4번째 element가 없음에도 컴파일은 가능합니다.\n하지만, 코드를 실행할 시, Dog[3]에 도달하는 순간 null.weightInPounds에 접근하게 되며 NullPointerException 에러가 발생합니다.\n아래와 같이 아무 매개변수 없이 object를 instantiation하면 어떻게 될까요?\npublic class DogLauncher { public static void main(String[] args) { Dog my_dog = new Dog(); ... Java 에서는 위의 Dog class와 같이 constructor가 하나라도 정의되어있는 경우 default constructor가 제공되지 않습니다. public class Dog { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; public Dog() { weightInPounds = 10; } ... constructor가 하나도 정의되어 있지 않은 경우 실행되는 \u0026ldquo;일종의\u0026rdquo; default constructor는 클래스의 instantiation과 관련하여 아무런 작업을 하지 않습니다. DogLauncher.java 실행 결과 public class DogLauncher { public static class DogTest { public int weightInPounds; public static String binomen = \u0026#34;Canis familiaris\u0026#34;; } public static void main(String[] args) { DogTest my_dog = new DogTest(); System.out.println(my_dog.weightInPounds); } } 0 DogTest의 default constructor가 없지만 \u0026ldquo;일종의\u0026rdquo; 초기화가 이루어집니다. 하지만 아주 기본적인 초기화(weightInPounds를 0으로 할당하는)가 이루어집니다.\n"
},
{
	"uri": "/kr/lecture2/content1/",
	"title": "Classes and Objects, Static, Types",
	"tags": [],
	"description": "",
	"content": "이번 노트에서는 다음과 같은 내용을 다룹니다.\n자바의 메소드 (Method) 자바 프로그램이 실행되기까지 (컴파일러, JVM) Class와 object static과 non-static Methods in Java Classes 파이썬에서 두 변수의 크기를 비교하는 함수를 작성해보면 아래와 같습니다. def larger(a, b): return a \u0026gt; b print(larger(3, 2)) print(larger(1, 2)) print(larger(\u0026#34;google\u0026#34;, \u0026#34;apple\u0026#34;)) print(larger(\u0026#34;han\u0026#34;, \u0026#34;yang\u0026#34;)) # 결과 True False True False 만약 서로 자료형을 가진 두 변수를 전달하게 되면, 아래와 같은 오류가 발생합니다. 두 input 매개변수의 자료형이 다르면 크기 비교를 할 수 없기 때문입니다. Traceback (most recent call last): File \u0026#34;main.py\u0026#34;, line 11, in \u0026lt;module\u0026gt; print(larger(\u0026#34;han\u0026#34;, 3)) File \u0026#34;main.py\u0026#34;, line 2, in larger return a \u0026gt; b TypeError: \u0026#39;\u0026gt;\u0026#39; not supported between instances of \u0026#39;str\u0026#39; and \u0026#39;int\u0026#39; larger를 Java에서 구현해봅시다. LargerDemo라는 클래스를 생성하고, larger 함수를 만들어봅시다. 자바 클래스 안에 작성한 함수는 메소드라고 불립니다.\nLargerDemo.java 실행 결과 class LargerDemo { larger(a, b){ return a \u0026gt; b; } } ./LargerDemo.java:2: error: invalid method declaration; return type required larger(a, b){ ^ ./LargerDemo.java:2: error: \u0026lt;identifier\u0026gt; expected larger(a, b){ ^ ./LargerDemo.java:2: error: \u0026lt;identifier\u0026gt; expected larger(a, b){ ^ 3 errors exit status 1 파이썬의 코드를 그대로 가져와 실행한 결과, 오류가 발생합니다. 우선 올바른 구현을 확인한 뒤 어떠한 수정이 필요했는지 살펴봅시다.\nclass LargerDemo { public static boolean larger(int a, int b) { return a \u0026gt; b; } public static void main(String[] args) { larger(1, 3); } } 자바는 input 매개변수들과 return값에 대하여 타입을 명시해주어야 합니다. 자바는 파이썬과 달리 main 함수가 반드시 필요합니다. 자바의 static 메소드는 오직 static 메소드만 호출할 수 있습니다. 현재 main 함수가 static 메소드이므로 LargerDemo의 non-static 메소드는 호출할 수 없습니다.\n지금은 실행을 위해 이해 없이 static을 붙였지만, object에 대해 배워보면서 이들의 차이점을 다시 살펴봅시다.\n또다른 포인트로, 파이썬에서와 같이 int, float, String 과 같은 여러 데이터 타입에 대해 범용성을 갖고 싶다면, 같은 이름을 가진 클래스 메소드를 만들어주면 됩니다. public class LargerDemo { public static boolean larger(int a, int b) { return a \u0026gt; b; } public static boolean larger(double a, double b) { return a \u0026gt; b; } public static void main(String[] args) { System.out.println(larger(3, 2)); System.out.println(larger(3.3, 2.2)); } } 이를 메소드 오버로딩이라 부르며, 오버로딩을 위해서는 몇가지 조건이 충족되어야 합니다.\n메소드 오버로딩의 조건\n메소드의 이름이 같아야 합니다. 메소드 매개변수의 개수 또는 타입이 달라야 합니다. 참고로, 메소드 오버로딩은 return 타입과는 관계가 없습니다. 만약 return 타입만 다른 경우에는 오버로딩이 성립하지 않습니다.\nString에 대하여 large 메소드를 구현하고 싶다면, 크기 비교 시 자바에 내장된 compareTo 함수를 사용하면 됩니다.\npublic class LargerDemo { public static boolean larger(int a, int b) { return a \u0026gt; b; } /* 이렇게는 사용 불가! */ // public static boolean larger(int a, int b) { // return a - b; // } public static boolean larger(double a, double b) { return a \u0026gt; b; } public static boolean larger(String a, String b) { return a.compareTo(b) \u0026lt; 0; } public static void main(String[] args) { System.out.println(larger(3, 2)); System.out.println(larger(3.3, 2.2)); System.out.println(larger(\u0026#34;Apple\u0026#34;, \u0026#34;Yang\u0026#34;)); } } Java and Static Typing 자바에서 변수의 타입은 정해지면 바꿀 수 없습니다. - Static Typing 파이썬의 경우, 타입을 프로그램 실행 중 바꿀 수 있었기 때문에, larger 함수가 문자열에도 적용되었던 것입니다. static typing의 장단점을 살펴봅시다.\n장점\n컴파일 타임에 에러를 체크 가능 (런타임 타임 에러를 해결하는 것은 몹시 힘듭니다. 😂 ) 메소드의 호출 시 정해진 타입만 넣게 되므로 에러를 줄일 수 있습니다. input/output이 어떤 데이터 타입인지 명확하기 때문에 코드를 읽기 쉽습니다. 코드 실행의 효율성이 증가합니다. 단점\n코드가 길어지고 난잡해집니다. (앞서 large 메소드만 보더라도 3개 타입에 대해서 오버로딩을 모두 구현해야 했습니다.) Java Compilation Java 프로그램이 컴파일되고 실행되기까지의 과정을 살펴봅시다.\n.java로 끝나는 자바 코드를 작성하였다면, 자바 컴파일러인 javac를 사용하여 이를 .class 파일로 변환, 컴파일합니다. 예를 들어, LargerDemo.java라는 파일을 컴파일했다면, LargerDemo.class라는 컴파일 결과를 얻게 됩니다. 이 과정을 콘솔 터미널 상에서 나타내면 아래와 같습니다.\n~/LargerDemo$ javac LargerDemo.java ~/LargerDemo$ ls LargerDemo.class LargerDemo.java Main.class replit.nix ~/LargerDemo$ java LargerDemo.class \u0026gt; 실행 결과 javac의 컴파일 결과로 얻게 된 .class 파일은 bytecode라고 불립니다. 이 bytecode는 기존 C/C++에서의 컴파일과는 차이점을 갖습니다. 자바 코드는 JVM이라는 자바 실행을 위한 가상 컴퓨터에서 실행되기 때문에, .class 파일만 있다면 윈도우, 리눅스, MacOS와 무관하게, 그리고 intel, arm과 같은 아키텍처와 무관하게 코드를 실행할 수 있습니다. 이렇게 코드를 한차례 컴파일 한 뒤 실행하는 것의 장점이 무엇일까요?\n.class은 이미 컴파일러가 타입 체크 등 자신이 할 수 있는 검사를 미리 해두었기 때문에 실행이 보다 안전해집니다. 기계어에 좀 더 가깝기 때문에 일반 코드보다 실행이 빠릅니다. 항상 그렇지는 않지만 타인이 내가 작성한 코드를 볼 수 없게 할 수 있습니다. Defining and Instantiating Classes \u0026ldquo;구글 맵\u0026quot;상에 식당을 나타내는 클래스를 구현하고 싶습니다.\nGoogleMaps.java Restaurant.java public class GoogleMaps { public static void main(String[] args) { Restaurant m = new Restaurant(); m.name = \u0026#34;McDonald\u0026#39;s\u0026#34;; m.rating = 3.9; m.isDineInAllowed = true; Restaurant w = new Restaurant(); w.name = \u0026#34;Wangsibli\u0026#34;; w.rating = 5.0; w.isDineInAllowed = true; System.out.println(m.name); System.out.println(w.name); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; } 식당 class를 만듦으로 새로운 식당을 추가할 때 매우 편리하게 구현이 가능해졌습니다. 그리고 이렇게 만들어진 식당 하나하나들은 object가 되며, 이것이 실제 메모리에 존재하는 값이 됩니다. 이번에는 일전 LargerDemo에서와 같이, 메소드를 추가해 봅시다.\nGoogleMaps.java Restaurant.java 실행 결과 public class GoogleMaps { public static void main(String[] args) { Restaurant m = new Restaurant(); m.name = \u0026#34;McDonald\u0026#39;s\u0026#34;; m.rating = 3.9; m.isDineInAllowed = true; Restaurant w = new Restaurant(); w.name = \u0026#34;Wangsibli\u0026#34;; w.rating = 5.0; w.isDineInAllowed = true; System.out.println(m.name); System.out.println(m.rating); m.increaseRating(0.5); System.out.println(m.name); System.out.println(m.rating); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; public void increaseRating(double inc){ rating += inc; } } McDonald\u0026#39;s 3.9 McDonald\u0026#39;s 4.4 클래스의 메소드를 static으로 선언하게 되면, object의 생성 없이도 클래스 이름을 통해서 메소드를 호출할 수 있습니다. 예시를 통해 살펴봅시다.\nGoogleMaps.java Restaurant.java 실행 결과 public class GoogleMaps { public static void main(String[] args) { Restaurant.restCall(); } } public class Restaurant { public String name; public double rating; public boolean isDineInAllowed; public static void restCall(){ System.out.println(\u0026#34;Hello Restaurant!\u0026#34;); } public void increaseRating(double inc){ rating += inc; } } Hello Restaurant! 만약 특정 메소드를 static으로 만들고 싶다면, 해당 메소드 내에서 사용되는 모든 변수들이 static 타입을 가져야 함에 유의합니다. 때문에, increaseRating을 static으로 바꿀 수는 없습니다. increaseRating안에서 사용되는 rating이 static 변수가 아니기 때문입니다. IntelliJ는 이러한 오류를 감지하여 사용자에게 알려줄 수 있습니다.\n"
},
{
	"uri": "/kr/lecture1/hello_world/",
	"title": "Hello World",
	"tags": [],
	"description": "",
	"content": "다양한 언어에서 Hello World를 콘솔 출력해봅시다.\nPython print(\u0026#34;Hello World\u0026#34;) C #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } Python과 C의 차이점은 무엇일까요? 많은 차이가 있지만, 큰 맥락에서 이야기해봅시다.\n파이썬은 코드를 한 줄씩 실행하는 인터프리터 언어인 반면, C는 기계어로의 변환이 필요한 컴파일 언어입니다.\n따라서 컴파일러에게 코드의 시작을 알리기 위해 main이라는 함수를 두게 됩니다.\nJava를 통해 Hello World를 출력하기 위해서는 다음과 같은 코드를 사용합니다.\npublic class Hello { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); } } Java 코드는 클래스 안에 존재해야 하며, 클래스의 이름은 파일 이름과 동일해야 합니다. C와 유사하게 main 함수가 필수적이며, main 함수는 항상 public이어야 합니다. 그리고 main함수의 매개변수는 String의 배열이어야 합니다. 💡 IntelliJ에서 psvm을 입력하면 main 함수를 바로 생성할 수 있습니다.\n"
},
{
	"uri": "/kr/lecture6/content2/",
	"title": "Generic Lists, AList, 2D Arrays",
	"tags": [],
	"description": "",
	"content": " Generic Lists AList 2D Arrays Generic Lists 지금까지의 SLList, DLList는 모두 item에 int 타입의 데이터만 담을 수 있었습니다. String, double 등 모든 타입에 대해서 List가 동작하도록 하기 위해, class generic을 사용해 봅시다.\nclass generic을 사용하기 위해서는 클래스의 정의 시 \u0026lt;\u0026gt; 연산자를 추가하고 generic의 지칭할 키워드를 명시합니다. 아래 예에서는 T를 키워드로 사용하고 있습니다. T는 어떤 이름으로 해도 무관합니다. 이제, 클래스 내부에서의 구현 시, generic이 적용되는 모든 부분에 실제 타입 대신 T를 써주면 됩니다. public class SLList\u0026lt;T\u0026gt; { private IntNode sentinel; private int size; public class IntNode { public T item; public IntNode next; ... } ... } ... /* 사용 예시 */ SLList\u0026lt;Integer\u0026gt; s1 = new SLList\u0026lt;\u0026gt;(5); s1.insertFront(10); SLList\u0026lt;String\u0026gt; s2 = new SLList\u0026lt;\u0026gt;(\u0026#34;hi\u0026#34;); s2.insertFront(\u0026#34;apple\u0026#34;); SLList\u0026lt;Restaurant\u0026gt; s3 = new SLList\u0026lt;\u0026gt;(); s3.insertFront(new Restaurant(“Popeyes”, 4.5)); 클래스 generic을 위한 \u0026lt;\u0026gt; 연산자 안에는 reference type만이 들어갈 수 있습니다. primitive type을 generic class로 사용하기 위해서는 아래와 같이 별도의 키워드를 사용합니다.\nint: Integer double: Double char: Character boolean: Boolean long: Long etc… AList array와 class object 사이의 공통점과 차이점을 살펴봅시다.\n두 변수 모두, 특정 memory box를 지칭하는 포인터라는 점에서 공통점을 갖지만, array는 [] 연산자를 통해 특정 index에 접근할 수 있다는 점에서 차이를 갖습니다.\nclass member는 모두 이름을 가진 반면 (Walrus.name), array의 각 element들은 각각을 지칭하는 이름이 없다는 점에서 차이점을 갖습니다.\narray의 기본 public class ArrayBasics { public static void main(String[] args) { int[] z = null; int[] x, y; x = new int[]{1, 2, 3, 4, 5}; y = x; x = new int[]{-1, 2, 5, 4, 99}; y = new int[3]; z = new int[0]; int xL = x.length; String[] s = new String[6]; s[4] = \u0026#34;ketchup\u0026#34;; s[x[3] - x[1]] = \u0026#34;muffins\u0026#34;; int[] b = {9, 10, 11}; System.arraycopy(b, 0, x, 3, 2); } } 코드 출처 : http://goo.gl/tFyMEJ array의 여러 성질들\narray 자체는 pointer에 해당합니다. (reference type이기 때문에) array는 reference type이기 때문에 array의 assignment는 pointer가 가리키는 메모리를 변경하는 것이 됩니다. array의 길이는 .length를 통해 얻을 수 있습니다. int 타입의 array를 declaration하면 모든 값은 기본적으로 0을 가지며, string 타입의 array를 declaration하면 모든 값이 기본적으로 null을 갖게 됩니다. System.arraycopy()를 통해 array간 빠른 복사가 가능합니다. (arraycopy의 사용법은 python의 slicing과 유사합니다.) System.arraycopy(b, 0, x, 3, 2); (In Python): x[3:5] = b[0:2] 2D Arrays 행렬과 유사하게 2D array를 사용할 수 있으며, 2D arrary를 declaration하는 방법은 크게 두 가지가 있습니다.\ninstantiation 시 모든 element의 값을 지정해주는 방법 각 element를 new 키워드를 통해 instantiation 하는 방법 아래 예시와 사진은 파스칼의 삼각형을 2D array로 구현하고 있습니다.\npublic class ArrayBasics2 { public static void main(String[] args) { int[][] pascalsTriangle; pascalsTriangle = new int[4][]; int[] rowZero = pascalsTriangle[0]; pascalsTriangle[0] = new int[]{1}; pascalsTriangle[1] = new int[]{1, 1}; pascalsTriangle[2] = new int[]{1, 2, 1}; pascalsTriangle[3] = new int[]{1, 3, 3, 1}; int[] rowTwo = pascalsTriangle[2]; rowTwo[1] = -5; int[][] matrix; matrix = new int[4][]; matrix = new int[4][4]; int[][] pascalAgain = new int[][]{{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}}; } } 2D array 퀴즈 - 아래 코드를 실행한 뒤 x[0][0]과 w[0][0]은 어떤 값을 가지게 될까요?\npublic class SomeClass { public static void main(String[] args) { int[][] x = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; int[][] z = new int[3][]; // 3 * N 2D array 생성 z[0] = x[0]; // z[0] = {1, 2, 3} z[0][0] = -z[0][0]; // z[0] = {-1, 2, 3} int[][] w = new int[3][3]; // 3 * 3 2D array 생성 System.arraycopy(x[0], 0, w[0], 0, 3); // w[0] = {-1, 2, 3} w[0][0] = -w[0][0]; // w[0][0] = 1 } } 정답 및 코드 출처 : https://goo.gl/CqrZ7Y w는 완전히 새로운 2D array이지만, z는 array를 reference하는 1D array라고 볼 수 있습니다.\narray와 클래스의 차이점을 조금 더 알아봅시다. array의 indexing 시 런타임 타임 변수를 사용할 수 있지만, 클래스의 member를 참조하고자 할 때는 컴파일 타임 변수를 사용해야 합니다. 예시를 통해 확인하겠습니다. Array\nCode 실행 결과 int[] x = new int[]{100, 101, 102, 103}; int indexOfInterest = askUser(); int k = x[indexOfInterest]; System.out.println(k); What index do you want? 2 102 indexOfInterest는 런타임 시 사용자에 의해 정해지는 변수이지만, array의 index에 사용해도 무관합니다.\nClass\nCode 실행 결과 String fieldOfInterest = \u0026#34;mass\u0026#34;; Planet earth = new Planet(6e24, \u0026#34;earth\u0026#34;); double mass = earth.fieldOfInterest; System.out.println(mass); ClassDemo.java:5: error: array required, but Planet found. double mass = earth[fieldOfInterest]; fieldOfInterest가 mass이므로, earth.fieldOfInterest는 earth.mass가 되니 괜찮지 않나 싶을 수 있지만, fieldOfInterest는 컴파일 타임에는 확실히 알 수 없는 변수입니다. 예를 들어 누군가 fieldOfInterest = “weight”라는 코드를 중간에 삽입한다면 오류가 발생할 수 있습니다. AList Array를 통해 list를 구현하는 AList라는 자료구조를 만들어 봅시다.\nAList를 구현하면서, 반드시 지켜야 할 몇 가지 원칙들이 있습니다.\n새로운 item이 추가될 시, items[size]에 추가됩니다. AList의 전체 item 수는 size입니다. AList 가장 마지막 item의 index는 항상 size - 1이 됩니다. public class AList { private int[] items; private int size; public AList(){ items = new int[100]; size = 0; } public void addLast(int x){ items[size] = x; size += 1; } public int getLast(){ return items[size - 1]; } public int get(int i){ return items[i]; } public int size(){ return size; } } AList의 removeLast를 구현할 시, 기존 item을 0으로 초기화하는 작업은 불필요합니다. 어차피 사용하지 않는 부분이기 때문에 어떤 수가 들어가있던 무관합니다. public int removeLast(){ int returnItem = items[size - 1]; items[size - 1] = 0; size -= 1; return returnItem; } Resizing Arrays AList에 계속해서 item이 추가되고, array의 최대 크기에 임박한 경우, 새로운 array를 만들고 기존 item을 복사해주어야 합니다. 이 과정 시, 새롭게 생성하는 array의 크기를 어떻게 지정하는지에 따라 수행 속도가 달라집니다. private void resize(int capacity){ int[] a = new int[capacity]; System.arraycopy(items, 0, a, 0, size); items = a; } public void addLast(int x){ if(size == items.length){ resize(size + 1); } items[size] = x; size += 1; } "
},
{
	"uri": "/kr/lecture5/content2/",
	"title": "PUBLIC VS PRIVATE, Nested Classes",
	"tags": [],
	"description": "",
	"content": " Public vs. Private Nested Classes 현재의 SLList는 사용자가 first member에 직접 접근이 가능하기 때문에 아래와 같이 SLList의 순서를 마음대로 조작할 수 있게 됩니다.\nSLList L = new SLList(15); L.addFirst(10); L.first.next.next = L.first.next; 이러한 위험을 막기 위해, first member는 오로지 클래스 내부에서만 사용 가능하도록 private 키워드를 추가할 수 있습니다. private 키워드인 member를 클래스 밖에서 접근하려고 하면 컴파일 에러가 발생하기 때문에 실수를 방지할 수 있습니다. 사용자 측면에서도 클래스에 대해 필요한 부분만 사용하면 되기 때문에 complexity가 줄어들게 됩니다. public class SLList { private IntNode first; ... 자동차를 표현하는 “Car”라는 클래스를 구현하고자 하는 경우를 생각해 봅시다.\n사용자와 직접 상호 작용하는 페달, 운전대, 변속기는 public 권한을 두어 사용자가 접근할 수 있도록 해야 합니다. 엔진 시스템, 자동차 내부 밸브 등 기계 요소들은 사용자에게 노출되어서는 안될 것이며, private 권한을 두어야 합니다. private 키워드를 사용한다는 것은 구현 상의 권한일 뿐이지 해커의 공격에서 안전하게 보호해준다는 뜻은 아닙니다. 😊\nNested Classes Java에서는 클래스 안에 또다른 클래스 구현을 허용하고 있습니다.\n아래와 같이 하위 클래스를 private static을 구현하게 되면, SLList 외부에서는 IntNode에 접근 불가하며, IntNode에서도 SLList의 member에 접근할 수 없게 됩니다.\n(static 클래스는 오로지 static member만 사용할 수 있습니다.)\npublic class SLList { private static class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; } ... Java의 access control을 정리해보면 아래 사진과 같습니다.\n가장 관대한 public과 가장 엄격한 private 사이에 protected와 package private 키워드가 존재합니다. 아무런 access control keyword가 없다면, 기본적으로 package private이 주어집니다. 출처 : https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html 어떤 access control을 지정해야 할지 모르겠다면, 가장 엄격한 private을 최우선으로 사용하고, 필요에 따라 한 단계씩 느슨한 access control을 지정하면 됩니다.\n앞으로는 무조건 public을 사용하기보다. private을 더 우선으로 사용합시다.\nSLList 업그레이드 size method 수정 SLList의 size() method는 사용자가 사용해야 하기 때문에 public 권한을 가져야 하지만, 동시에 size() method안에서 사용되는 로직은 굳이 노출될 필요가 없습니다. 이러한 경우, private method와 public method를 분리하여 구현할 수 있습니다. public class SLList { ... private int size(IntNode p) { if (p.next == null) { return 1; } return 1 + size(p.next); } public int size() { return size(first); } } "
},
{
	"uri": "/kr/lecture4/content2/",
	"title": "Unit Test &amp; Integration Test, Simpler JUnit Tests, Primtive Types",
	"tags": [],
	"description": "",
	"content": " Unit Test \u0026amp; Integration Test Simpler JUnit Tests Primtive Types Unit Test \u0026amp; Integration Test 방대한 코드는 수많은 하위 기능들의 조합으로 구성되며, 이러한 작은 하위 기능의 단위를 Unit이라고 칭할 때, 이 Unit들을 Testing하는 작업을 Unit Test라고 합니다.\nJUnit은 이런 Unit Test를 편리하게 작업할 수 있도록 해주는 Java의 툴입니다.\nTest-Driven Development (TDD)\n일전 예시와 같이 구현하고자 하는 기능의 Test code를 먼저 작성하고, 그 test code에 맞추어 코드를 개발하는 과정을 TDD라고 합니다. 구현한 코드가 모든 Test를 통과하게 된다면 Refactoring을 수행하며, 다시 새로운 기능의 Test Code를 작성함으로 과정을 반복하면서, 차츰 차츰 거대한 프로젝트를 구성해나갈 수 있습니다. 출처 : https://medium.com/pplink/tdd로-프론트엔드-개발-날로-먹기-a95e428d929 Integration Test Unit Test를 모두 통과했다 하더라도, 코드 전체의 동작이 제대로 수행되는 것은 별개의 테스트가 필요합니다. 이렇게 좀 더 큰 범위의 코드들을 테스트하고 개선하는 것을 Integration test라고 합니다.\n테스트 시스템을 탄탄하게 다져두면, 이후의 개발 시 높은 효율을 얻을 수 있습니다.\n출처 : https://www.exasol.com/resource/integration-testing-why-you-need-it-and-how-to-make-it-painless/ Primtive Types Java에는 8가지의 primitive type이 존재하며, 이를 제외한 모든 type들은 모두 reference type이 됩니다.\n출처 : https://www.geeksforgeeks.org/data-types-in-java/ 퀴즈 - 아래 예시에서, b의 변경이 a에 영향이 있을까요?\nWalrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); 코드를 통해 확인해 봅시다.\nWalrusQuiz.java 실행 결과 public class WalrusQuiz { public static class Walrus { int weight = 0; double tusk = 0.0; public Walrus(int weight, double tusk){ this.weight = weight; this.tusk = tusk; } public String toString() { return new String(\u0026#34;weight : \u0026#34; + weight + \u0026#34; / tush : \u0026#34; + tusk); } } public static void main(String[] args) { Walrus a = new Walrus(1000, 8.3); Walrus b; b = a; b.weight = 5; System.out.println(a); System.out.println(b); } } weight : 5 / tush : 8.3 weight : 5 / tush : 8.3 Walrus 클래스는 reference type 이기 때문에, b의 변경이 a에게도 영향을 미치게 됩니다. 만약 weight가 클래스의 static member였다면 위 예시는 어떻게 동작했을까요?\nWalrusQuiz.java 실행 결과 public class WalrusQuiz { public static class Walrus { static int weight = 1000; double tusk = 0.0; } public static void main(String[] args) { Walrus a = new Walrus(); Walrus b = new Walrus(); System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); Walrus.weight = 10; System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); } } a.weight : 1000\tb.weight : 1000 a.weight : 10\tb.weight : 10 static member를 변경하게 되면 해당 클래스의 모든 object들의 static member 값이 변경됩니다. 만약 이러한 변경을 막고 싶다면, 클래스 내에서 final 키워드를 사용하면 됩니다. public class WalrusQuiz { public static class Walrus { static final int weight = 1000; double tusk = 0.0; } public static void main(String[] args) { Walrus a = new Walrus(); Walrus b = new Walrus(); System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); Walrus.weight = 10; // 컴파일 에러 System.out.println(\u0026#34;a.weight : \u0026#34; + a.weight + \u0026#34;\\t b.weight : \u0026#34; + b.weight); } } 앞선 Walrus 퀴즈 결과와 비교하면서, 아래 예시를 실행하면 x의 변화가 y의 값에 영향을 줄지 생각해 봅시다.\nPrimitiveQuiz.java 실행결과 public class PrimitiveQuiz { public static void main(String[] args) { int x = 5; int y; y = x; x = 2; System.out.println(\u0026#34;x is \u0026#34; + x); System.out.println(\u0026#34;y is \u0026#34; + y); } } x is 2 y is 5 이러한 차이를 갖는 이유는 int는 primitive type인 반면, Walrus는 reference type이기 때문입니다. 앞서 언급한 바와 같이 Java에는 8가지의 primitive type이 있으며, 이를 제외한 나머지 type은 모두 reference type이 됩니다. primitive type 변수를 declaration하게 되면, 해당 변수에 일정 크기의 빈 메모리 box가 할당됩니다.\n출처 : https://sp21.datastructur.es/ 변수에 값을 대입하게 되면 메모리 box에 실제 값이 들어가게 되는 것이지요. (이러한 개념을 box notation이라고 부르겠습니다.)\nbox notation에서 y = x라는 대입은 x box에 있던 모든 비트를 y 박스의 비트로 복사하겠다는 뜻이 됩니다. 반면, reference type 변수를 declaration하고 assignment하는 방식은 primitive type과 큰 차이가 있습니다. 아래 예시를 통해 reference type의 declaration과 assignment를 살펴봅시다. public class PollQuestions { public static void main(String[] args) { Walrus a = new Walrus(1000, 8.3); } public static class Walrus { public int weight; public double tuskSize; public Walrus(int w, double ts) { weight = w; tuskSize = ts; } } } reference type 변수를 declaration하면, 해당 변수에는 아무 값을 갖지 않는 pointer가 할당됩니다. declaration된 변수를 instantiation하면, 이 시점에 a는 weight와 tuskSize를 가진 object를 가리키게 (point) 됩니다. a 자체는 값을 가진 것이 아니라, a가 가리키는 곳으로 가야 실제 값이 존재하는 것이지요. reference type간의 복사는 실제 값이 복사되는 것이 아니라, 두 pointer가 같은 값을 가리키게 되는 식으로 동작합니다. 때문에, a의 member를 변경할 시 b에도 영향을 미치게 됩니다. 강의에서는 이러한 개념을 “box and pointer” notation이라고 칭하고 있습니다.\n일전, String object의 비교 시 == 연산자를 사용할 수 없었던 점을 다시 생각해봅시다.\nString a = new String(\u0026#34;Hello\u0026#34;); String b = new String(\u0026#34;Hello\u0026#34;); if(a == b) // Nope :( if(a.equals(b)) // Yes :) ... 서로 다른 reference type을 비교한다는 것은 해당 reference type 즉, pointer를 비교하는 것에 지나지 않습니다. 실제 우리가 원하는 비교는 해당 pointer가 가리키고 있는 실제 존재하는 값을 비교하고 싶은 것입니다. a는 분명 b와 같은 값을 갖고 있는데, == 연산자로는 둘이 같은지 구분할 수가 없습니다. == 연산자는 단순히 c와 a 자체 즉, pointer를 비교하고 있기 때문입니다. "
},
{
	"uri": "/kr/lecture3/content2/",
	"title": "Managing Complexity (Helper Method)",
	"tags": [],
	"description": "",
	"content": " 코드의 complexity를 관리하기 (helper method) Managing Complexity with Helper Methods 왜 자바에서는 모든 코드가 클래스안에 존재하며, static method를 사용하고 있을까요?\n코드의 complexity를 낮추고, 사용자의 실수를 방지할 수 있기 때문입니다. static method를 사용하면, 사용자, 혹은 다른 프로그래머가 가용한 option이 적어지며, 이는 오류의 option을 줄이게 됩니다. helper method 사용하는 모든 코드가 main 함수 안에 구현되어 있다고 생각해봅시다. 방대한 코드는 가독성을 떨어뜨릴 뿐더러, 실수를 유발합니다.\n이러한 문제를 해결하기 위해 우리는 helper method를 사용하여 코드를 분리하고 정리합니다.\nlargerThanFourNeighbors 예시를 통해 살펴봅시다.\n해당 element가 좌우 2개씩, 총 4개의 element들과 비교해서 가장 크다면 해당 element를 추가하여 output array를 만듭니다.\n예를 들어, [10, 20, 30, 25, 20, 40, 10]이 input으로 사용된 경우, output은 [30, 40]이 됩니다.\n30 is greater than 10, 20, 25, and 20. 40 is greater than 25, 20, and 10. 구현은 다음과 같습니다.\nlargerThanFourNeighbors public static Dog[] largerThanFourNeighbors(Dog[] dogs) { Dog[] returnDogs = new Dog[dogs.length]; int count = 0; for(int i = 0; i \u0026lt; dogs.length; i++){ boolean isBigger = true; for(int j = i - 2; j \u0026lt;= i + 2; j++){ if(j \u0026lt; 0 || j \u0026gt;= dogs.length || j == i){ continue; } if(dogs[i].weightInPounds \u0026lt;= dogs[j].weightInPounds){ isBigger = false; } } if(isBigger) { returnDogs[count] = dogs[i]; count++; } } Dog[] answerDogs = new Dog[count]; for(int i = 0; i \u0026lt; count; i++){ answerDogs[i] = returnDogs[i]; } return answerDogs; } 방대한 양의 코드가 작성되었으며, 가독성 또한 떨어졌습니다.\n이 상황에서 helper function을 통해 작성된 코드의 complexity를 줄여봅시다.\nanswerDogs을 생성하며 array를 복사하는 부분을 별도의 method로 분리해봅시다.\nhelper method를 작성할 때는 항상 method의 input과 output에 주의하여 코드를 작성합니다.\ninput : 원본 array와 복사를 원하는 element의 개수 output : 복사가 완료된 새로운 array public static Dog[] createNewDogs(Dog[] originalDogs, int count) { Dog[] answerDogs = new Dog[count]; for (int i = 0; i \u0026lt; count; i++) { answerDogs[i] = originalDogs[i]; } return answerDogs; } 추가로 주변 4개의 이웃 element들과 크기를 비교해주는 helper method도 작성해봅시다.\ninput : 원본 array와 현재 탐색하기 원하는 index output : 조건을 만족했는지의 여부를 boolean으로 return public static boolean isBiggerThanFourNeighbors(int currentIndex, Dog[] dogs) { for (int j = currentIndex - 2; j \u0026lt;= currentIndex + 2; j++) { if (j \u0026lt; 0 || j \u0026gt;= dogs.length || currentIndex == j) { continue; } if (dogs[currentIndex].weightInPounds \u0026lt;= dogs[j].weightInPounds) { return false; } } return true; } 최종 정리된 코드는 다음과 같습니다. 기존 코드보다 가독성도 높아지고 실수가 발생할 여지 또한 줄어들었습니다.\nlargerThanFourNeighbors public static boolean isBiggerThanFourNeighbors(int currentIndex, Dog[] dogs) { for (int j = currentIndex - 2; j \u0026lt;= currentIndex + 2; j++) { if (j \u0026lt; 0 || j \u0026gt;= dogs.length || currentIndex == j) { continue; } if (dogs[currentIndex].weightInPounds \u0026lt;= dogs[j].weightInPounds) { return false; } } return true; } public static Dog[] largerThanFourNeighbors(Dog[] dogs) { Dog[] returnDogs = new Dog[dogs.length]; int count = 0; for (int i = 0; i \u0026lt; dogs.length; i++) { if (isBiggerThanFourNeighbors(i, dogs)) { returnDogs[count] = dogs[i]; count = count + 1; } } return createNewDogs(returnDogs, count); } public static Dog[] createNewDogs(Dog[] originalDogs, int count) { Dog[] answerDogs = new Dog[count]; for (int i = 0; i \u0026lt; count; i++) { answerDogs[i] = originalDogs[i]; } return answerDogs; } "
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]